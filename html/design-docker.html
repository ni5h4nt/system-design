<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Design Docker ‚Äî Worked Example</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&family=DM+Sans:ital,wght@0,400;0,500;0,600;0,700&family=Fraunces:ital,opsz,wght@0,9..144,700;1,9..144,400&display=swap" rel="stylesheet">
<style>
  :root {
    --bg: #0e1117; --surface: #161b22; --surface-raised: #1c2129;
    --border: #2d333b; --border-light: #373e47;
    --text: #e6edf3; --text-muted: #8b949e; --text-dim: #6e7681;
    --accent-blue: #58a6ff; --accent-green: #3fb950; --accent-orange: #d29922;
    --accent-red: #f85149; --accent-purple: #bc8cff; --accent-cyan: #39d2c0; --accent-yellow: #e3b341;
    --phase1: #58a6ff; --phase2: #d29922; --phase3: #3fb950; --phase4: #f85149; --phase5: #bc8cff; --phase6: #39d2c0;
    --nav-width: 270px;
    --font-body: 'DM Sans', -apple-system, sans-serif;
    --font-mono: 'JetBrains Mono', monospace;
    --font-display: 'Fraunces', Georgia, serif;
  }
  * { margin: 0; padding: 0; box-sizing: border-box; }
  html { scroll-behavior: smooth; scroll-padding-top: 24px; }
  body { font-family: var(--font-body); background: var(--bg); color: var(--text); font-size: 14px; line-height: 1.6; }
  nav { position: fixed; top: 0; left: 0; width: var(--nav-width); height: 100vh; background: var(--surface); border-right: 1px solid var(--border); padding: 24px 0; overflow-y: auto; z-index: 100; display: flex; flex-direction: column; }
  nav .logo { padding: 0 20px 20px; border-bottom: 1px solid var(--border); margin-bottom: 16px; }
  nav .logo h1 { font-family: var(--font-display); font-size: 18px; font-weight: 700; color: var(--text); letter-spacing: -0.02em; line-height: 1.3; }
  nav .logo span { display: block; font-family: var(--font-body); font-size: 11px; color: var(--text-dim); margin-top: 4px; font-weight: 400; text-transform: uppercase; letter-spacing: 0.08em; }
  .nav-section-label { font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.1em; color: var(--text-dim); padding: 12px 20px 6px; }
  nav a { display: flex; align-items: center; gap: 10px; padding: 7px 20px; color: var(--text-muted); text-decoration: none; font-size: 13px; font-weight: 500; transition: all 0.15s; border-left: 2px solid transparent; }
  nav a:hover { color: var(--text); background: var(--surface-raised); }
  .nav-dot { width: 7px; height: 7px; border-radius: 50%; flex-shrink: 0; }
  .nav-time { margin-left: auto; font-family: var(--font-mono); font-size: 10px; color: var(--text-dim); background: var(--surface-raised); padding: 1px 6px; border-radius: 3px; }
  main { margin-left: var(--nav-width); padding: 32px 48px 120px; max-width: 960px; }
  .phase { margin-bottom: 40px; border: 1px solid var(--border); border-radius: 10px; overflow: hidden; background: var(--surface); }
  .phase-header { display: flex; align-items: center; gap: 14px; padding: 16px 20px; cursor: pointer; user-select: none; transition: background 0.15s; }
  .phase-header:hover { background: var(--surface-raised); }
  .phase-number { font-family: var(--font-mono); font-size: 11px; font-weight: 600; padding: 3px 8px; border-radius: 4px; color: var(--bg); flex-shrink: 0; }
  .phase-title { font-family: var(--font-display); font-size: 17px; font-weight: 700; flex: 1; }
  .phase-time { font-family: var(--font-mono); font-size: 12px; color: var(--text-muted); flex-shrink: 0; }
  .phase-chevron { width: 20px; height: 20px; color: var(--text-dim); transition: transform 0.25s ease; flex-shrink: 0; }
  .phase.collapsed .phase-chevron { transform: rotate(-90deg); }
  .phase.collapsed .phase-body { display: none; }
  .phase-body { padding: 0 20px 20px; border-top: 1px solid var(--border); }
  .callout { margin: 14px 0; padding: 12px 16px; border-radius: 0 6px 6px 0; font-size: 13px; line-height: 1.6; }
  .callout.goal { background: rgba(88,166,255,0.05); border-left: 3px solid var(--accent-blue); color: var(--text-muted); }
  .callout.goal strong { color: var(--accent-blue); }
  .callout.say { background: rgba(63,185,80,0.06); border-left: 3px solid var(--accent-green); color: var(--text-muted); }
  .callout.say::before { content: 'üó£Ô∏è '; }
  .callout.tip { background: rgba(210,153,34,0.06); border-left: 3px solid var(--accent-orange); color: var(--text-muted); }
  .callout.tip::before { content: 'üí° '; }
  .callout.decision { background: rgba(248,81,73,0.05); border-left: 3px solid var(--accent-red); color: var(--text-muted); }
  .callout.decision::before { content: '‚öñÔ∏è '; }
  .callout.warn { background: rgba(188,140,255,0.06); border-left: 3px solid var(--accent-purple); color: var(--text-muted); }
  .callout code { background: rgba(255,255,255,0.06); padding: 1px 5px; border-radius: 3px; font-family: var(--font-mono); font-size: 12px; }
  .sub { font-size: 14px; font-weight: 700; color: var(--accent-cyan); margin: 20px 0 8px; padding-bottom: 6px; border-bottom: 1px solid var(--border); }
  .items { list-style: none; margin: 10px 0; }
  .items li { position: relative; padding: 5px 0 5px 22px; font-size: 13.5px; line-height: 1.55; color: var(--text-muted); }
  .items li::before { content: '‚Üí'; position: absolute; left: 2px; color: var(--text-dim); font-family: var(--font-mono); font-size: 12px; }
  .items li strong { color: var(--text); font-weight: 600; }
  table { width: 100%; border-collapse: collapse; font-size: 12.5px; margin: 12px 0; }
  thead th { text-align: left; font-size: 10px; text-transform: uppercase; letter-spacing: 0.08em; color: var(--text-dim); padding: 8px 10px; border-bottom: 1px solid var(--border-light); font-weight: 600; }
  tbody td { padding: 8px 10px; border-bottom: 1px solid var(--border); vertical-align: top; line-height: 1.5; color: var(--text-muted); }
  tbody tr:last-child td { border-bottom: none; }
  tbody td:first-child { font-weight: 600; color: var(--text); font-family: var(--font-mono); font-size: 11.5px; white-space: nowrap; }
  .est-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin: 14px 0; }
  .est-card { padding: 12px 14px; border: 1px solid var(--border); border-radius: 8px; background: var(--surface-raised); }
  .est-card .label { font-size: 10px; text-transform: uppercase; letter-spacing: 0.08em; color: var(--text-dim); margin-bottom: 4px; }
  .est-card .value { font-family: var(--font-mono); font-size: 18px; font-weight: 600; color: var(--accent-yellow); }
  .est-card .detail { font-size: 11.5px; color: var(--text-dim); margin-top: 4px; line-height: 1.4; }
  .schema { background: var(--surface-raised); border: 1px solid var(--border); border-radius: 8px; padding: 14px 16px; margin: 12px 0; font-family: var(--font-mono); font-size: 12px; line-height: 1.7; color: var(--text-muted); overflow-x: auto; white-space: pre; }
  .schema .table-name { color: var(--accent-cyan); font-weight: 600; }
  .schema .pk { color: var(--accent-yellow); }
  .schema .fk { color: var(--accent-purple); }
  .schema .type { color: var(--text-dim); }
  .schema .comment { color: var(--text-dim); font-style: italic; }
  .api-block { background: var(--surface-raised); border: 1px solid var(--border); border-radius: 8px; margin: 10px 0; overflow: hidden; }
  .api-method { display: inline-flex; align-items: center; gap: 10px; padding: 8px 14px; font-family: var(--font-mono); font-size: 12px; width: 100%; border-bottom: 1px solid var(--border); }
  .api-method .verb { padding: 2px 8px; border-radius: 4px; font-weight: 600; font-size: 10px; text-transform: uppercase; }
  .api-method .verb.post { background: rgba(63,185,80,0.15); color: var(--accent-green); }
  .api-method .verb.get { background: rgba(88,166,255,0.15); color: var(--accent-blue); }
  .api-method .verb.put { background: rgba(210,153,34,0.15); color: var(--accent-orange); }
  .api-method .verb.delete { background: rgba(248,81,73,0.15); color: var(--accent-red); }
  .api-method .path { color: var(--text); }
  .api-method .desc { margin-left: auto; color: var(--text-dim); font-size: 11px; font-family: var(--font-body); }
  .api-body { padding: 10px 14px; font-size: 12px; color: var(--text-dim); line-height: 1.55; }
  .flow-diagram { background: var(--surface-raised); border: 1px solid var(--border); border-radius: 8px; padding: 20px; margin: 14px 0; font-family: var(--font-mono); font-size: 12px; line-height: 2; color: var(--text-muted); overflow-x: auto; white-space: pre; text-align: center; }
  .flow-diagram .highlight { color: var(--accent-cyan); font-weight: 600; }
  .flow-diagram .arrow { color: var(--text-dim); }
  .flow-diagram .label { color: var(--accent-orange); font-size: 10px; }
  .comp-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin: 12px 0; }
  .comp-card { padding: 12px 14px; border: 1px solid var(--border); border-radius: 8px; background: var(--surface-raised); }
  .comp-card h4 { font-size: 13px; font-weight: 600; color: var(--text); margin-bottom: 6px; display: flex; align-items: center; gap: 6px; }
  .comp-card h4 .tag { font-family: var(--font-mono); font-size: 9px; padding: 2px 6px; border-radius: 3px; font-weight: 600; }
  .comp-card ul { list-style: none; font-size: 12px; color: var(--text-muted); line-height: 1.55; }
  .comp-card ul li::before { content: '‚Ä¢ '; color: var(--text-dim); }
  .failure-row { display: flex; gap: 8px; margin: 6px 0; font-size: 12.5px; align-items: flex-start; }
  .failure-row .scenario { color: var(--accent-red); font-weight: 600; min-width: 180px; flex-shrink: 0; }
  .failure-row .mitigation { color: var(--text-muted); }
  @media (max-width: 900px) { nav { display: none; } main { margin-left: 0; padding: 20px 16px 80px; } .est-grid, .comp-grid { grid-template-columns: 1fr; } }
  .svg-diagram{margin:14px 0;border:1px solid var(--border);border-radius:8px;background:var(--surface-raised);overflow:hidden;position:relative}
  .svg-diagram svg{display:block;width:100%;height:auto}
  .svg-diagram .dia-title{position:absolute;top:10px;right:14px;font-family:var(--font-mono);font-size:9px;letter-spacing:.08em;text-transform:uppercase;color:var(--text-dim);opacity:.6}
</style>
</head>
<body>

<nav>
  <div class="logo">
    <h1>Design Docker</h1>
    <span>Worked Example ¬∑ 75 min</span>
  </div>
  <div class="nav-section-label">Interview Phases</div>
  <a href="#p1"><span class="nav-dot" style="background:var(--phase1)"></span>Clarify &amp; Scope<span class="nav-time">5-7m</span></a>
  <a href="#p2"><span class="nav-dot" style="background:var(--phase2)"></span>Estimation<span class="nav-time">3-5m</span></a>
  <a href="#p3"><span class="nav-dot" style="background:var(--phase3)"></span>High-Level Design<span class="nav-time">8-12m</span></a>
  <a href="#p4"><span class="nav-dot" style="background:var(--phase4)"></span>Deep Dives<span class="nav-time">25-30m</span></a>
  <a href="#p5"><span class="nav-dot" style="background:var(--phase5)"></span>Cross-Cutting<span class="nav-time">10-12m</span></a>
  <a href="#p6"><span class="nav-dot" style="background:var(--phase6)"></span>Wrap-Up<span class="nav-time">3-5m</span></a>
  <div class="nav-section-label">Deep Dives</div>
  <a href="#dd-runtime">Container Runtime</a>
  <a href="#dd-images">Image Build &amp; Registry</a>
  <a href="#dd-networking">Container Networking</a>
  <a href="#dd-data">Data Model &amp; Storage</a>
  <div class="nav-section-label">Reference</div>
  <a href="#failures">Failure Scenarios</a>
  <a href="#evolution">Evolution</a>
  <a href="#p7"><span class="nav-dot" style="background:var(--accent-cyan)"></span>Interview Q&amp;A<span class="nav-time">Practice</span></a>
</nav>

<main>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê PHASE 1: CLARIFY ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<div class="phase" id="p1">
  <div class="phase-header" onclick="this.closest('.phase').classList.toggle('collapsed')">
    <span class="phase-number" style="background:var(--phase1)">01</span>
    <span class="phase-title">Clarify the Problem &amp; Scope</span><span class="phase-time">5‚Äì7 min</span>
    <svg class="phase-chevron" viewBox="0 0 20 20" fill="currentColor"><path d="M6.3 6.3a1 1 0 011.4 0L10 8.6l2.3-2.3a1 1 0 111.4 1.4l-3 3a1 1 0 01-1.4 0l-3-3a1 1 0 010-1.4z"/></svg>
  </div>
  <div class="phase-body">

    <div class="callout say">"We're designing a container platform like Docker ‚Äî the system that builds, distributes, and runs containers. That spans three distinct subsystems: a runtime that isolates and executes processes, a registry that stores and distributes images, and a CLI/API that ties them together. Let me scope this."</div>

    <div class="sub">Questions I'd Ask</div>
    <ul class="items">
      <li><strong>Single-host or orchestrated?</strong> Just `docker run` on one machine, or multi-host orchestration (Swarm/K8s)? <em>‚Üí Focus on single-host runtime + registry. Mention orchestration as evolution.</em></li>
      <li><strong>Build, ship, or run ‚Äî all three?</strong> <em>‚Üí All three: docker build (image creation), docker push/pull (registry), docker run (container lifecycle).</em></li>
      <li><strong>Container type?</strong> Linux containers (namespaces/cgroups), Windows containers, or VMs? <em>‚Üí Linux containers. The core isolation primitives.</em></li>
      <li><strong>Registry: self-hosted (Docker Registry) or cloud (Docker Hub)?</strong> <em>‚Üí Design both: the storage backend and the distribution protocol.</em></li>
      <li><strong>Security model?</strong> Root vs rootless, image signing, vulnerability scanning? <em>‚Üí In scope: namespace isolation, image trust. Out of scope: deep CVE scanning.</em></li>
      <li><strong>Scale?</strong> How many images, how many running containers per host? <em>‚Üí Registry: millions of images, billions of pulls/day. Runtime: ~100-500 containers per host.</em></li>
    </ul>

    <div class="sub">Agreed Scope</div>
    <table>
      <thead><tr><th>In Scope</th><th>Out of Scope</th></tr></thead>
      <tbody>
        <tr><td>Container runtime (create, start, stop, exec)</td><td>Multi-host orchestration (Kubernetes)</td></tr>
        <tr><td>Image building (Dockerfile ‚Üí image)</td><td>CI/CD pipeline integration</td></tr>
        <tr><td>Image registry (push, pull, storage)</td><td>CVE / vulnerability scanning</td></tr>
        <tr><td>Container networking (bridge, host, overlay basics)</td><td>Service mesh (Istio, Linkerd)</td></tr>
        <tr><td>Storage: volumes, layers, copy-on-write</td><td>Windows containers</td></tr>
        <tr><td>Security: namespaces, cgroups, seccomp, image trust</td><td>Kubernetes CRI integration details</td></tr>
      </tbody>
    </table>

    <div class="sub">Core Use Cases</div>
    <ul class="items">
      <li><strong>UC1: docker build</strong> ‚Äî Developer writes a Dockerfile ‚Üí system produces an immutable, layered image</li>
      <li><strong>UC2: docker push / pull</strong> ‚Äî Image is uploaded to a registry and distributed to any host</li>
      <li><strong>UC3: docker run</strong> ‚Äî Host creates an isolated process with its own filesystem, network, and resource limits</li>
      <li><strong>UC4: docker exec</strong> ‚Äî Attach to a running container for debugging</li>
      <li><strong>UC5: docker stop / rm</strong> ‚Äî Graceful shutdown with SIGTERM ‚Üí SIGKILL, cleanup resources</li>
    </ul>

    <div class="sub">Non-Functional Requirements</div>
    <ul class="items">
      <li><strong>Container startup &lt;1 second:</strong> Containers must start near-instantly compared to VMs (minutes). This is the core value proposition ‚Äî lightweight process isolation.</li>
      <li><strong>Image layer deduplication:</strong> 1000 containers sharing the same base image (Ubuntu 22.04) should NOT store 1000 copies. Copy-on-write (CoW) filesystem is essential.</li>
      <li><strong>Hard isolation between containers:</strong> A compromised container must NOT be able to access another container's filesystem, network, or processes. Security boundary = defense in depth.</li>
      <li><strong>Registry pull latency:</strong> Cold pull of a 500MB image should complete in &lt;30 seconds. Incremental pull (only missing layers) in &lt;5 seconds.</li>
      <li><strong>Registry availability:</strong> If the registry is down, already-pulled images can still run. Registry is on the critical path for deployment, not for runtime.</li>
      <li><strong>Resource limits must be enforced:</strong> A container configured for 512MB RAM must be OOM-killed if it exceeds this. No noisy neighbor ‚Äî cgroups must be hard limits.</li>
    </ul>

    <div class="callout tip">The key architectural insight: Docker is NOT a virtual machine. It's process isolation using Linux kernel primitives (namespaces for isolation, cgroups for resource limits, union filesystems for layered storage). The container IS a Linux process ‚Äî just one that thinks it's the only process on the machine.</div>

  </div>
</div>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê PHASE 2: ESTIMATION ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<div class="phase" id="p2">
  <div class="phase-header" onclick="this.closest('.phase').classList.toggle('collapsed')">
    <span class="phase-number" style="background:var(--phase2);color:var(--bg)">02</span>
    <span class="phase-title">Back-of-the-Envelope Estimation</span><span class="phase-time">3‚Äì5 min</span>
    <svg class="phase-chevron" viewBox="0 0 20 20" fill="currentColor"><path d="M6.3 6.3a1 1 0 011.4 0L10 8.6l2.3-2.3a1 1 0 111.4 1.4l-3 3a1 1 0 01-1.4 0l-3-3a1 1 0 010-1.4z"/></svg>
  </div>
  <div class="phase-body">

    <div class="callout say">"Let me estimate the scale for both the runtime (per-host) and the registry (global)."</div>

    <div class="est-grid">
      <div class="est-card">
        <div class="label">Containers / Host</div>
        <div class="value">100‚Äì500</div>
        <div class="detail">K8s node: 110 pods default max. Dense hosting: 500+</div>
      </div>
      <div class="est-card">
        <div class="label">Container Startup</div>
        <div class="value">&lt;500ms</div>
        <div class="detail">Create namespace + cgroup + mount layers + exec. No kernel boot.</div>
      </div>
      <div class="est-card">
        <div class="label">Image Size (avg)</div>
        <div class="value">~200 MB</div>
        <div class="detail">Alpine: 5MB, Ubuntu: 80MB, Python app: 300MB, Java: 500MB+</div>
      </div>
      <div class="est-card">
        <div class="label">Image Layers (avg)</div>
        <div class="value">~8-15 layers</div>
        <div class="detail">Base OS + package install + app copy + entrypoint</div>
      </div>
      <div class="est-card">
        <div class="label">Registry: Total Images</div>
        <div class="value">~15M+ repos</div>
        <div class="detail">Docker Hub: 15M+ repositories, billions of tags</div>
      </div>
      <div class="est-card">
        <div class="label">Registry: Pulls / Day</div>
        <div class="value">~1B+</div>
        <div class="detail">Docker Hub: billions of pulls/day. CI/CD drives majority.</div>
      </div>
    </div>

    <div class="callout decision"><strong>Key insight #1:</strong> The copy-on-write filesystem is what makes Docker practical. 500 containers from the same image share ONE copy of the base layers on disk. Without CoW, 500 containers √ó 200MB = 100GB. With CoW: 200MB shared + 500 √ó ~5MB writable layers = ~2.7GB. A 37x storage reduction.</div>

    <div class="callout decision"><strong>Key insight #2:</strong> Registry bandwidth dominates cost. A 200MB image pulled 1B times/day = 200 PB/day of transfer. Content-addressable storage + CDN + layer deduplication are essential ‚Äî most pulls share 80% of layers with an existing local image.</div>

    <div class="callout decision"><strong>Key insight #3:</strong> Container startup is fast because there's NO OS boot. The kernel is already running (it's the host kernel). We're just creating a new process with isolated namespaces. Compare: VM boot (30-60 seconds, boot kernel) vs container start (&lt;1 second, fork + exec).</div>

  </div>
</div>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê PHASE 3: HIGH-LEVEL DESIGN ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<div class="phase" id="p3">
  <div class="phase-header" onclick="this.closest('.phase').classList.toggle('collapsed')">
    <span class="phase-number" style="background:var(--phase3);color:var(--bg)">03</span>
    <span class="phase-title">High-Level Design</span><span class="phase-time">8‚Äì12 min</span>
    <svg class="phase-chevron" viewBox="0 0 20 20" fill="currentColor"><path d="M6.3 6.3a1 1 0 011.4 0L10 8.6l2.3-2.3a1 1 0 111.4 1.4l-3 3a1 1 0 01-1.4 0l-3-3a1 1 0 010-1.4z"/></svg>
  </div>
  <div class="phase-body">

    <div class="callout say">"Docker has three planes: the CLI/API client, the daemon that manages containers on a single host, and the registry that stores and distributes images. Let me walk through each."</div>

    <div class="sub">Key Architecture Decisions</div>
    <div class="callout say">"Here's WHY I chose each technology ‚Äî mapping requirements to tradeoffs. Every choice has a rejected alternative and a consequence."</div>
    <table>
      <thead><tr><th style="width:22%">Requirement</th><th style="width:20%">Decision</th><th style="width:42%">Why (and what was rejected)</th><th style="width:16%">Consistency</th></tr></thead>
      <tbody>
        <tr><td>Sub-second container start</td><td style="color:var(--accent-cyan);font-weight:500">Linux namespaces + cgroups (not VMs)</td><td>No kernel boot. Process isolation via kernel primitives. VMs require hypervisor + guest OS boot (30-60s). Trade: weaker isolation (shared kernel).</td><td>‚Äî</td></tr>
        <tr><td>500 containers share one base image</td><td style="color:var(--accent-cyan);font-weight:500">OverlayFS (copy-on-write layers)</td><td>Layers are immutable and shared. Only writes create new data. AUFS is legacy, devicemapper is slow on metadata. OverlayFS is mainline kernel.</td><td>‚Äî</td></tr>
        <tr><td>Image identity must be tamper-proof</td><td style="color:var(--accent-cyan);font-weight:500">Content-addressable storage (SHA-256)</td><td>Image ID = hash of content. Changing 1 byte changes the hash. Tag-based identity is mutable ("latest" can point to anything). Hash-based is immutable.</td><td>CP</td></tr>
        <tr><td>Registry must serve billions of pulls/day</td><td style="color:var(--accent-cyan);font-weight:500">Blob storage (S3) + CDN + layer dedup</td><td>Layers stored once in S3 regardless of how many images reference them. CDN caches popular layers at edge. DB-stored blobs can't scale to petabytes.</td><td>AP</td></tr>
        <tr><td>Containers need isolated networking</td><td style="color:var(--accent-cyan);font-weight:500">Network namespaces + veth pairs + bridge</td><td>Each container gets its own IP, routing table, iptables. Bridge connects containers on same host. Shared host networking leaks isolation.</td><td>‚Äî</td></tr>
        <tr><td>Resource limits must be hard (no noisy neighbor)</td><td style="color:var(--accent-cyan);font-weight:500">cgroups v2 for CPU, memory, I/O</td><td>Kernel-enforced limits. OOM killer fires if memory exceeded. CPU shares for fair scheduling. Userspace enforcement is bypassable.</td><td>‚Äî</td></tr>
      </tbody>
    </table>

    <div class="sub">Major Components</div>
    <div class="svg-diagram" data-anim>
      <span class="dia-title">High-Level Architecture</span>
      <svg viewBox="0 0 780 580" xmlns="http://www.w3.org/2000/svg" style="font-family:'DM Sans',sans-serif">
        <defs>
          <marker id="arr" markerWidth="7" markerHeight="5" refX="7" refY="2.5" orient="auto"><path d="M0,0 L7,2.5 L0,5" fill="none" stroke="#6e7681" stroke-width="1"/></marker>
          <marker id="arrh" markerWidth="7" markerHeight="5" refX="7" refY="2.5" orient="auto"><path d="M0,0 L7,2.5 L0,5" fill="none" stroke="#39d2c0" stroke-width="1"/></marker>
        </defs>
        <!-- Layer backgrounds -->
        <rect x="28" y="20" width="724" height="72" rx="8" fill="rgba(88,166,255,.02)" stroke="rgba(88,166,255,.12)" stroke-dasharray="4 2"/>
        <text x="40" y="33" fill="#58a6ff" font-size="8" font-weight="600" letter-spacing=".1em" opacity=".7">CLIENT</text>
        <rect x="28" y="108" width="724" height="72" rx="8" fill="rgba(210,153,34,.02)" stroke="rgba(210,153,34,.12)" stroke-dasharray="4 2"/>
        <text x="40" y="121" fill="#d29922" font-size="8" font-weight="600" letter-spacing=".1em" opacity=".7">DOCKER DAEMON (dockerd)</text>
        <rect x="28" y="196" width="724" height="72" rx="8" fill="rgba(63,185,80,.02)" stroke="rgba(63,185,80,.12)" stroke-dasharray="4 2"/>
        <text x="40" y="209" fill="#3fb950" font-size="8" font-weight="600" letter-spacing=".1em" opacity=".7">CONTAINER RUNTIME</text>
        <rect x="28" y="284" width="724" height="72" rx="8" fill="rgba(248,81,73,.02)" stroke="rgba(248,81,73,.12)" stroke-dasharray="4 2"/>
        <text x="40" y="297" fill="#f85149" font-size="8" font-weight="600" letter-spacing=".1em" opacity=".7">LINUX KERNEL</text>
        <rect x="28" y="372" width="358" height="72" rx="8" fill="rgba(188,140,255,.02)" stroke="rgba(188,140,255,.12)" stroke-dasharray="4 2"/>
        <text x="40" y="385" fill="#bc8cff" font-size="8" font-weight="600" letter-spacing=".1em" opacity=".7">STORAGE</text>
        <rect x="398" y="372" width="354" height="72" rx="8" fill="rgba(57,210,192,.02)" stroke="rgba(57,210,192,.12)" stroke-dasharray="4 2"/>
        <text x="410" y="385" fill="#39d2c0" font-size="8" font-weight="600" letter-spacing=".1em" opacity=".7">REGISTRY (REMOTE)</text>
        <!-- Nodes -->
        <g class="svg-node"><rect x="80" y="38" width="140" height="40" rx="6" fill="#161b22" stroke="#58a6ff" stroke-width="1.2"/><text x="150" y="56" fill="#58a6ff" font-size="11" text-anchor="middle" font-weight="600">Docker CLI</text><text x="150" y="68" fill="#6e7681" font-size="8" text-anchor="middle">docker build|run|push</text></g>
        <g class="svg-node"><rect x="300" y="38" width="180" height="40" rx="6" fill="#161b22" stroke="#58a6ff" stroke-width="1.2"/><text x="390" y="56" fill="#58a6ff" font-size="11" text-anchor="middle" font-weight="600">REST API</text><text x="390" y="68" fill="#6e7681" font-size="8" text-anchor="middle">/v1.43/containers/* (Unix socket)</text></g>
        <g class="svg-node"><rect x="560" y="38" width="150" height="40" rx="6" fill="#161b22" stroke="#58a6ff" stroke-width="1.2"/><text x="635" y="56" fill="#58a6ff" font-size="11" text-anchor="middle" font-weight="600">Docker Compose</text><text x="635" y="68" fill="#6e7681" font-size="8" text-anchor="middle">Multi-container defs</text></g>
        <g class="svg-node"><rect x="60" y="126" width="140" height="40" rx="6" fill="#161b22" stroke="#d29922" stroke-width="1.2"/><text x="130" y="144" fill="#d29922" font-size="11" text-anchor="middle" font-weight="600">Image Manager</text><text x="130" y="156" fill="#6e7681" font-size="8" text-anchor="middle">Build, tag, push, pull</text></g>
        <g class="svg-node"><rect x="230" y="126" width="140" height="40" rx="6" fill="#161b22" stroke="#d29922" stroke-width="1.2"/><text x="300" y="144" fill="#d29922" font-size="11" text-anchor="middle" font-weight="600">Container Manager</text><text x="300" y="156" fill="#6e7681" font-size="8" text-anchor="middle">Create, start, stop, rm</text></g>
        <g class="svg-node"><rect x="400" y="126" width="140" height="40" rx="6" fill="#161b22" stroke="#d29922" stroke-width="1.2"/><text x="470" y="144" fill="#d29922" font-size="11" text-anchor="middle" font-weight="600">Network Manager</text><text x="470" y="156" fill="#6e7681" font-size="8" text-anchor="middle">Bridge, veth, iptables</text></g>
        <g class="svg-node"><rect x="570" y="126" width="140" height="40" rx="6" fill="#161b22" stroke="#d29922" stroke-width="1.2"/><text x="640" y="144" fill="#d29922" font-size="11" text-anchor="middle" font-weight="600">Volume Manager</text><text x="640" y="156" fill="#6e7681" font-size="8" text-anchor="middle">Bind mounts, named vols</text></g>
        <g class="svg-node"><rect x="100" y="214" width="140" height="40" rx="6" fill="#161b22" stroke="#3fb950" stroke-width="1.2"/><text x="170" y="232" fill="#3fb950" font-size="11" text-anchor="middle" font-weight="600">containerd</text><text x="170" y="244" fill="#6e7681" font-size="8" text-anchor="middle">Container lifecycle shim</text></g>
        <g class="svg-node"><rect x="310" y="214" width="140" height="40" rx="6" fill="#161b22" stroke="#3fb950" stroke-width="1.2"/><text x="380" y="232" fill="#3fb950" font-size="11" text-anchor="middle" font-weight="600">runc</text><text x="380" y="244" fill="#6e7681" font-size="8" text-anchor="middle">OCI runtime (fork+exec)</text></g>
        <g class="svg-node"><rect x="520" y="214" width="170" height="40" rx="6" fill="#161b22" stroke="#3fb950" stroke-width="1.2"/><text x="605" y="232" fill="#3fb950" font-size="11" text-anchor="middle" font-weight="600">containerd-shim</text><text x="605" y="244" fill="#6e7681" font-size="8" text-anchor="middle">Reparents after runc exits</text></g>
        <g class="svg-node"><rect x="60" y="302" width="120" height="40" rx="6" fill="#161b22" stroke="#f85149" stroke-width="1.2"/><text x="120" y="320" fill="#f85149" font-size="11" text-anchor="middle" font-weight="600">Namespaces</text><text x="120" y="332" fill="#6e7681" font-size="8" text-anchor="middle">pid,net,mnt,uts,ipc,user</text></g>
        <g class="svg-node"><rect x="210" y="302" width="120" height="40" rx="6" fill="#161b22" stroke="#f85149" stroke-width="1.2"/><text x="270" y="320" fill="#f85149" font-size="11" text-anchor="middle" font-weight="600">cgroups v2</text><text x="270" y="332" fill="#6e7681" font-size="8" text-anchor="middle">CPU, mem, I/O limits</text></g>
        <g class="svg-node"><rect x="360" y="302" width="120" height="40" rx="6" fill="#161b22" stroke="#f85149" stroke-width="1.2"/><text x="420" y="320" fill="#f85149" font-size="11" text-anchor="middle" font-weight="600">seccomp</text><text x="420" y="332" fill="#6e7681" font-size="8" text-anchor="middle">Syscall filtering</text></g>
        <g class="svg-node"><rect x="510" y="302" width="120" height="40" rx="6" fill="#161b22" stroke="#f85149" stroke-width="1.2"/><text x="570" y="320" fill="#f85149" font-size="11" text-anchor="middle" font-weight="600">OverlayFS</text><text x="570" y="332" fill="#6e7681" font-size="8" text-anchor="middle">Union mount (CoW)</text></g>
        <g class="svg-node"><rect x="660" y="302" width="80" height="40" rx="6" fill="#161b22" stroke="#f85149" stroke-width="1.2"/><text x="700" y="320" fill="#f85149" font-size="11" text-anchor="middle" font-weight="600">netfilter</text><text x="700" y="332" fill="#6e7681" font-size="8" text-anchor="middle">iptables/nftables</text></g>
        <g class="svg-node"><rect x="50" y="390" width="140" height="40" rx="6" fill="#161b22" stroke="#bc8cff" stroke-width="1.2"/><text x="120" y="408" fill="#bc8cff" font-size="11" text-anchor="middle" font-weight="600">Image Layers</text><text x="120" y="420" fill="#6e7681" font-size="8" text-anchor="middle">/var/lib/docker/overlay2</text></g>
        <g class="svg-node"><rect x="220" y="390" width="140" height="40" rx="6" fill="#161b22" stroke="#bc8cff" stroke-width="1.2"/><text x="290" y="408" fill="#bc8cff" font-size="11" text-anchor="middle" font-weight="600">Volumes</text><text x="290" y="420" fill="#6e7681" font-size="8" text-anchor="middle">/var/lib/docker/volumes</text></g>
        <g class="svg-node"><rect x="420" y="390" width="140" height="40" rx="6" fill="#161b22" stroke="#39d2c0" stroke-width="1.2"/><text x="490" y="408" fill="#39d2c0" font-size="11" text-anchor="middle" font-weight="600">Blob Store (S3)</text><text x="490" y="420" fill="#6e7681" font-size="8" text-anchor="middle">Content-addressable</text></g>
        <g class="svg-node"><rect x="590" y="390" width="140" height="40" rx="6" fill="#161b22" stroke="#39d2c0" stroke-width="1.2"/><text x="660" y="408" fill="#39d2c0" font-size="11" text-anchor="middle" font-weight="600">Manifest DB</text><text x="660" y="420" fill="#6e7681" font-size="8" text-anchor="middle">PostgreSQL (tag‚Üídigest)</text></g>
        <!-- Connections -->
        <line x1="150" y1="78" x2="150" y2="126" stroke="#6e7681" stroke-width="1" marker-end="url(#arr)"/>
        <line x1="390" y1="78" x2="300" y2="126" stroke="#6e7681" stroke-width="1" marker-end="url(#arr)"/>
        <line x1="300" y1="166" x2="170" y2="214" stroke="#6e7681" stroke-width="1" marker-end="url(#arr)"/>
        <line x1="170" y1="254" x2="380" y2="214" stroke="#6e7681" stroke-width="1" marker-end="url(#arr)"/>
        <line x1="380" y1="254" x2="270" y2="302" stroke="#6e7681" stroke-width="1" marker-end="url(#arr)"/>
        <line x1="380" y1="254" x2="120" y2="302" stroke="#6e7681" stroke-width="1" marker-end="url(#arr)"/>
        <line x1="380" y1="254" x2="420" y2="302" stroke="#6e7681" stroke-width="1" marker-end="url(#arr)"/>
        <line x1="605" y1="254" x2="570" y2="302" stroke="#6e7681" stroke-width="1" marker-end="url(#arr)"/>
        <line x1="130" y1="166" x2="490" y2="390" stroke="#39d2c0" stroke-width="1" stroke-dasharray="4 2" marker-end="url(#arrh)"/>
        <text x="320" y="285" fill="#39d2c0" font-size="8" opacity=".7">push/pull</text>
        <!-- Runc to kernel arrow set -->
        <line x1="570" y1="342" x2="290" y2="390" stroke="#6e7681" stroke-width="1" marker-end="url(#arr)"/>
      </svg>
    </div>

    <div class="comp-grid">
      <div class="comp-card">
        <h4>Docker CLI <span class="tag" style="background:rgba(88,166,255,.15);color:var(--accent-blue)">CLIENT</span></h4>
        <ul>
          <li>Parses commands, sends REST calls to daemon via Unix socket</li>
          <li>Handles build context (tar + send to daemon)</li>
          <li>Streams logs, attach, exec via HTTP hijack</li>
        </ul>
      </div>
      <div class="comp-card">
        <h4>Docker Daemon (dockerd) <span class="tag" style="background:rgba(210,153,34,.15);color:var(--accent-orange)">DAEMON</span></h4>
        <ul>
          <li>REST API server on Unix socket /var/run/docker.sock</li>
          <li>Manages images, containers, networks, volumes</li>
          <li>Delegates container lifecycle to containerd</li>
        </ul>
      </div>
      <div class="comp-card">
        <h4>containerd <span class="tag" style="background:rgba(63,185,80,.15);color:var(--accent-green)">RUNTIME</span></h4>
        <ul>
          <li>Container lifecycle management (create, start, stop)</li>
          <li>Image pull, unpack, snapshot management</li>
          <li>gRPC API ‚Äî Kubernetes CRI-compatible</li>
        </ul>
      </div>
      <div class="comp-card">
        <h4>runc <span class="tag" style="background:rgba(63,185,80,.15);color:var(--accent-green)">OCI RUNTIME</span></h4>
        <ul>
          <li>Creates namespaces, cgroups, mounts</li>
          <li>Forks container init process, then exits</li>
          <li>OCI Runtime Spec compliant (replaceable: crun, gVisor, Kata)</li>
        </ul>
      </div>
      <div class="comp-card">
        <h4>containerd-shim <span class="tag" style="background:rgba(63,185,80,.15);color:var(--accent-green)">SHIM</span></h4>
        <ul>
          <li>Reparents container process after runc exits</li>
          <li>Keeps STDIO open for logs and exec</li>
          <li>Allows containerd/dockerd restart without killing containers</li>
        </ul>
      </div>
      <div class="comp-card">
        <h4>Registry <span class="tag" style="background:rgba(57,210,192,.15);color:var(--accent-cyan)">DISTRIBUTION</span></h4>
        <ul>
          <li>OCI Distribution Spec: manifest + blob storage</li>
          <li>Content-addressable: blobs keyed by SHA-256</li>
          <li>S3 backend for blobs, PostgreSQL for tag‚Üídigest mapping</li>
        </ul>
      </div>
    </div>

    <div class="sub">Flow 1: docker run nginx (the happy path)</div>
    <div class="svg-diagram">
      <span class="dia-title">docker run ‚Üí Container Process</span>
      <svg viewBox="0 0 780 420" xmlns="http://www.w3.org/2000/svg" style="font-family:'DM Sans',sans-serif">
        <defs>
          <marker id="d1" markerWidth="7" markerHeight="5" refX="7" refY="2.5" orient="auto"><path d="M0,0 L7,2.5 L0,5" fill="none" stroke="#6e7681" stroke-width="1"/></marker>
        </defs>

        <!-- CLI ‚Üí dockerd ‚Üí containerd -->
        <rect x="40" y="20" width="100" height="34" rx="6" fill="#161b22" stroke="#58a6ff" stroke-width="1.5"/>
        <text x="90" y="41" fill="#58a6ff" font-size="10" text-anchor="middle" font-weight="600">CLI</text>
        <line x1="140" y1="37" x2="210" y2="37" stroke="#58a6ff" stroke-width="1" marker-end="url(#d1)"/>
        <text x="175" y="30" fill="#58a6ff" font-size="7" text-anchor="middle">REST</text>
        <rect x="210" y="20" width="120" height="34" rx="6" fill="#161b22" stroke="#3fb950" stroke-width="1.5"/>
        <text x="270" y="41" fill="#3fb950" font-size="10" text-anchor="middle" font-weight="600">dockerd</text>
        <line x1="330" y1="37" x2="400" y2="37" stroke="#3fb950" stroke-width="1" marker-end="url(#d1)"/>
        <text x="365" y="30" fill="#3fb950" font-size="7" text-anchor="middle">gRPC</text>
        <rect x="400" y="20" width="140" height="34" rx="6" fill="#161b22" stroke="#d29922" stroke-width="1.5"/>
        <text x="470" y="41" fill="#d29922" font-size="10" text-anchor="middle" font-weight="600">containerd</text>

        <!-- Branch: Pull + Snapshot -->
        <line x1="440" y1="54" x2="300" y2="90" stroke="#6e7681" stroke-width="1" marker-end="url(#d1)"/>
        <line x1="500" y1="54" x2="600" y2="90" stroke="#6e7681" stroke-width="1" marker-end="url(#d1)"/>

        <rect x="200" y="90" width="200" height="34" rx="5" fill="#161b22" stroke="var(--border)" stroke-width="1"/>
        <text x="300" y="105" fill="#58a6ff" font-size="9" text-anchor="middle" font-weight="600">Pull image</text>
        <text x="300" y="118" fill="#6e7681" font-size="7" text-anchor="middle">(if not already local)</text>

        <rect x="500" y="90" width="200" height="34" rx="5" fill="#161b22" stroke="var(--border)" stroke-width="1"/>
        <text x="600" y="105" fill="#58a6ff" font-size="9" text-anchor="middle" font-weight="600">Create snapshot</text>
        <text x="600" y="118" fill="#6e7681" font-size="7" text-anchor="middle">(OverlayFS mount)</text>

        <!-- Merge to runc -->
        <line x1="300" y1="124" x2="420" y2="155" stroke="#6e7681" stroke-width="1" marker-end="url(#d1)"/>
        <line x1="600" y1="124" x2="500" y2="155" stroke="#6e7681" stroke-width="1" marker-end="url(#d1)"/>

        <rect x="370" y="155" width="180" height="34" rx="5" fill="#161b22" stroke="#d29922" stroke-width="1"/>
        <text x="425" y="169" fill="#d29922" font-size="9" text-anchor="middle" font-weight="600">containerd</text>
        <text x="510" y="169" fill="#6e7681" font-size="8">‚îÄ‚îÄfork‚îÄ‚îÄ‚ñ∂</text>
        <rect x="540" y="155" width="100" height="34" rx="5" fill="#161b22" stroke="#f85149" stroke-width="1.5"/>
        <text x="590" y="176" fill="#f85149" font-size="10" text-anchor="middle" font-weight="600">runc</text>

        <!-- Namespaces + Cgroups -->
        <line x1="560" y1="189" x2="300" y2="225" stroke="#6e7681" stroke-width="1" marker-end="url(#d1)"/>
        <line x1="620" y1="189" x2="600" y2="225" stroke="#6e7681" stroke-width="1" marker-end="url(#d1)"/>

        <rect x="140" y="225" width="260" height="50" rx="5" fill="rgba(88,166,255,.04)" stroke="rgba(88,166,255,.15)" stroke-width="1"/>
        <text x="270" y="243" fill="#58a6ff" font-size="9" text-anchor="middle" font-weight="600">Create namespaces</text>
        <text x="270" y="258" fill="#6e7681" font-size="8" text-anchor="middle">pid, net, mnt, uts, ipc, user</text>
        <text x="270" y="270" fill="#6e7681" font-size="7" text-anchor="middle">Process isolation from host</text>

        <rect x="480" y="225" width="260" height="50" rx="5" fill="rgba(210,153,34,.04)" stroke="rgba(210,153,34,.15)" stroke-width="1"/>
        <text x="610" y="243" fill="#d29922" font-size="9" text-anchor="middle" font-weight="600">Set cgroups</text>
        <text x="610" y="258" fill="#6e7681" font-size="8" text-anchor="middle">CPU, memory, I/O limits</text>
        <text x="610" y="270" fill="#6e7681" font-size="7" text-anchor="middle">Resource isolation applied</text>

        <!-- Merge to fork+exec -->
        <line x1="270" y1="275" x2="420" y2="305" stroke="#6e7681" stroke-width="1" marker-end="url(#d1)"/>
        <line x1="610" y1="275" x2="480" y2="305" stroke="#6e7681" stroke-width="1" marker-end="url(#d1)"/>

        <rect x="320" y="305" width="260" height="40" rx="6" fill="#161b22" stroke="#3fb950" stroke-width="1.5"/>
        <text x="450" y="322" fill="#3fb950" font-size="10" text-anchor="middle" font-weight="600">fork + exec entrypoint</text>
        <text x="450" y="336" fill="#6e7681" font-size="8" text-anchor="middle">nginx master process, PID 1 inside container</text>

        <!-- runc exits -->
        <line x1="450" y1="345" x2="450" y2="370" stroke="#6e7681" stroke-width="1" marker-end="url(#d1)"/>
        <rect x="250" y="370" width="380" height="34" rx="6" fill="rgba(248,81,73,.04)" stroke="rgba(248,81,73,.15)" stroke-width="1"/>
        <text x="440" y="385" fill="#f85149" font-size="9" text-anchor="middle" font-weight="600">runc exits ‚Äî shim reparents container process</text>
        <text x="440" y="398" fill="#6e7681" font-size="7" text-anchor="middle">containerd/dockerd can restart without killing nginx</text>
      </svg>
    </div>

    <div class="sub">Flow 2: docker build (Dockerfile ‚Üí Image)</div>
    <div class="svg-diagram">
      <span class="dia-title">docker build ‚Äî Image Layer Creation</span>
      <svg viewBox="0 0 780 340" xmlns="http://www.w3.org/2000/svg" style="font-family:'DM Sans',sans-serif">
        <defs>
          <marker id="d2" markerWidth="7" markerHeight="5" refX="7" refY="2.5" orient="auto"><path d="M0,0 L7,2.5 L0,5" fill="none" stroke="#6e7681" stroke-width="1"/></marker>
        </defs>

        <!-- CLI ‚Üí dockerd -->
        <rect x="40" y="20" width="100" height="30" rx="6" fill="#161b22" stroke="#58a6ff" stroke-width="1.5"/>
        <text x="90" y="39" fill="#58a6ff" font-size="10" text-anchor="middle" font-weight="600">CLI</text>
        <line x1="140" y1="35" x2="240" y2="35" stroke="#58a6ff" stroke-width="1" marker-end="url(#d2)"/>
        <text x="190" y="28" fill="#6e7681" font-size="7" text-anchor="middle">tar build context</text>
        <rect x="240" y="20" width="200" height="30" rx="6" fill="#161b22" stroke="#3fb950" stroke-width="1.5"/>
        <text x="340" y="39" fill="#3fb950" font-size="10" text-anchor="middle" font-weight="600">dockerd (Image Builder)</text>

        <!-- Parse -->
        <line x1="290" y1="50" x2="200" y2="78" stroke="#6e7681" stroke-width="1" marker-end="url(#d2)"/>
        <rect x="80" y="78" width="240" height="30" rx="5" fill="#161b22" stroke="var(--border)" stroke-width="1"/>
        <text x="200" y="97" fill="#d29922" font-size="9" text-anchor="middle" font-weight="600">Parse Dockerfile (FROM, RUN, COPY...)</text>

        <!-- Loop label -->
        <line x1="390" y1="50" x2="560" y2="78" stroke="#6e7681" stroke-width="1" marker-end="url(#d2)"/>
        <text x="560" y="92" fill="#bc8cff" font-size="9" text-anchor="middle" font-weight="600">For each instruction:</text>

        <!-- Loop box -->
        <rect x="420" y="104" width="330" height="140" rx="8" fill="rgba(188,140,255,.03)" stroke="rgba(188,140,255,.12)" stroke-width="1" stroke-dasharray="5 3"/>

        <!-- Step 1: temp container -->
        <rect x="440" y="114" width="140" height="40" rx="5" fill="#161b22" stroke="#58a6ff" stroke-width="1"/>
        <text x="510" y="131" fill="#58a6ff" font-size="8" text-anchor="middle" font-weight="600">Create temp container</text>
        <text x="510" y="147" fill="#6e7681" font-size="7" text-anchor="middle">(from previous layer)</text>

        <!-- Step 2: execute -->
        <rect x="600" y="114" width="130" height="40" rx="5" fill="#161b22" stroke="#3fb950" stroke-width="1"/>
        <text x="665" y="131" fill="#3fb950" font-size="8" text-anchor="middle" font-weight="600">Execute instruction</text>
        <text x="665" y="147" fill="#6e7681" font-size="7" text-anchor="middle">RUN apt-get install</text>

        <!-- Arrow between -->
        <line x1="580" y1="134" x2="600" y2="134" stroke="#6e7681" stroke-width="1" marker-end="url(#d2)"/>

        <!-- Step 3: snapshot -->
        <line x1="510" y1="154" x2="510" y2="175" stroke="#6e7681" stroke-width="1" marker-end="url(#d2)"/>
        <rect x="440" y="175" width="140" height="36" rx="5" fill="#161b22" stroke="#d29922" stroke-width="1"/>
        <text x="510" y="190" fill="#d29922" font-size="8" text-anchor="middle" font-weight="600">Snapshot diff</text>
        <text x="510" y="203" fill="#6e7681" font-size="7" text-anchor="middle">(only changed files)</text>

        <!-- Step 4: commit -->
        <line x1="665" y1="154" x2="665" y2="175" stroke="#6e7681" stroke-width="1" marker-end="url(#d2)"/>
        <rect x="600" y="175" width="130" height="36" rx="5" fill="#161b22" stroke="#d29922" stroke-width="1"/>
        <text x="665" y="190" fill="#d29922" font-size="8" text-anchor="middle" font-weight="600">Commit as layer</text>
        <text x="665" y="203" fill="#6e7681" font-size="7" text-anchor="middle">(SHA-256 hash)</text>

        <!-- Loop arrow back -->
        <path d="M 585 216 Q 585 232 560 232 L 430 232 Q 420 232 420 222 L 420 120 Q 420 110 435 110" fill="none" stroke="#bc8cff" stroke-width="1" stroke-dasharray="4 2" marker-end="url(#d2)"/>
        <text x="410" y="175" fill="#bc8cff" font-size="7" transform="rotate(-90, 410, 175)">REPEAT</text>

        <!-- Final image -->
        <line x1="585" y1="244" x2="400" y2="280" stroke="#3fb950" stroke-width="1" marker-end="url(#d2)"/>
        <rect x="140" y="270" width="400" height="40" rx="6" fill="#161b22" stroke="#3fb950" stroke-width="1.5"/>
        <text x="340" y="288" fill="#3fb950" font-size="10" text-anchor="middle" font-weight="600">Final image = stack of layers + manifest</text>
        <text x="340" y="302" fill="#d29922" font-size="8" text-anchor="middle">Layer cache: if instruction unchanged ‚Üí reuse layer (instant)</text>
      </svg>
    </div>

  </div>
</div>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê PHASE 4: DEEP DIVES ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<div class="phase" id="p4">
  <div class="phase-header" onclick="this.closest('.phase').classList.toggle('collapsed')">
    <span class="phase-number" style="background:var(--phase4);color:var(--bg)">04</span>
    <span class="phase-title">Deep Dives</span><span class="phase-time">25‚Äì30 min</span>
    <svg class="phase-chevron" viewBox="0 0 20 20" fill="currentColor"><path d="M6.3 6.3a1 1 0 011.4 0L10 8.6l2.3-2.3a1 1 0 111.4 1.4l-3 3a1 1 0 01-1.4 0l-3-3a1 1 0 010-1.4z"/></svg>
  </div>
  <div class="phase-body">

    <!-- DD1: Container Runtime -->
    <div class="sub" id="dd-runtime">Deep Dive 1: Container Runtime ‚Äî Linux Primitives (~12 min)</div>

    <div class="callout goal"><strong>The core question: How does a container actually work?</strong> A container is NOT a VM. It's a regular Linux process that's been isolated using kernel features. Three primitives make it work: namespaces (isolation), cgroups (resource limits), and union filesystems (layered storage).</div>

    <table>
      <thead><tr><th>Namespace</th><th>What It Isolates</th><th>Why It Matters</th></tr></thead>
      <tbody>
        <tr><td>PID</td><td>Process tree</td><td>Container sees only its own processes. PID 1 inside = entrypoint. Host PID might be 48291.</td></tr>
        <tr><td>NET</td><td>Network stack</td><td>Container gets its own IP, routing table, iptables. Can't see host interfaces.</td></tr>
        <tr><td>MNT</td><td>Filesystem mounts</td><td>Container has its own root filesystem (from image layers). Can't see host /etc/passwd.</td></tr>
        <tr><td>UTS</td><td>Hostname</td><td>Container has its own hostname. `hostname` returns container ID, not host.</td></tr>
        <tr><td>IPC</td><td>System V IPC, POSIX MQ</td><td>Shared memory segments are per-container. Prevents cross-container IPC leakage.</td></tr>
        <tr><td>USER</td><td>UID/GID mapping</td><td>Root inside container (UID 0) maps to unprivileged user on host (UID 100000). Rootless containers.</td></tr>
      </tbody>
    </table>

    <div class="callout decision"><strong>Why not VMs?</strong> VMs provide stronger isolation (hardware-level via hypervisor) but at massive cost: each VM boots a full kernel (30-60s), consumes 200MB+ RAM for the guest OS, and can't share filesystem layers. Containers trade some isolation (shared kernel) for speed (&lt;1s start), density (500 per host vs 50 VMs), and efficiency (shared base layers). For multi-tenant isolation where tenants don't trust each other, VMs are still better (or gVisor/Kata Containers which use a lightweight VM per container).</div>

    <div class="callout tip">The <code>docker exec</code> command works by calling <code>setns()</code> to join an existing container's namespaces. It doesn't create a new container ‚Äî it attaches a new process to the same isolation boundary. This is why exec'd processes see the same filesystem and network as the container's main process.</div>

    <div class="schema"><span class="comment">// Container creation pseudocode (what runc does)</span>

<span class="table-name">fn create_container</span>(config: OCI_Spec) {
  <span class="comment">// 1. Create namespaces</span>
  pid_ns  = <span class="pk">unshare</span>(CLONE_NEWPID);
  net_ns  = <span class="pk">unshare</span>(CLONE_NEWNET);
  mnt_ns  = <span class="pk">unshare</span>(CLONE_NEWNS);
  uts_ns  = <span class="pk">unshare</span>(CLONE_NEWUTS);
  ipc_ns  = <span class="pk">unshare</span>(CLONE_NEWIPC);
  user_ns = <span class="pk">unshare</span>(CLONE_NEWUSER);

  <span class="comment">// 2. Set cgroup limits</span>
  cgroup = create_cgroup(<span class="fk">"/sys/fs/cgroup/docker/{container_id}"</span>);
  write(cgroup + "/memory.max", config.memory_limit);  <span class="comment">// e.g., "512m"</span>
  write(cgroup + "/cpu.max", config.cpu_quota);         <span class="comment">// e.g., "100000 100000" = 1 CPU</span>

  <span class="comment">// 3. Mount filesystem (OverlayFS)</span>
  mount("overlay", rootfs, "overlay",
    lowerdir=<span class="fk">image_layers</span>,   <span class="comment">// read-only, shared</span>
    upperdir=<span class="pk">container_rw</span>,    <span class="comment">// per-container writable layer</span>
    workdir=work_dir);

  <span class="comment">// 4. Apply security profiles</span>
  apply_seccomp(config.seccomp_profile);  <span class="comment">// block dangerous syscalls</span>
  apply_apparmor(config.apparmor_profile);
  drop_capabilities(config.cap_drop);     <span class="comment">// e.g., drop CAP_SYS_ADMIN</span>

  <span class="comment">// 5. Fork and exec entrypoint</span>
  child = <span class="pk">fork</span>();
  if child == 0 {
    <span class="pk">exec</span>(config.entrypoint, config.args);  <span class="comment">// becomes PID 1 inside container</span>
  }
  <span class="comment">// runc exits. containerd-shim becomes parent of the container process.</span>
}</div>

    <!-- DD2: Image Build & Registry -->
    <div class="sub" id="dd-images">Deep Dive 2: Image Build &amp; Registry (~10 min)</div>

    <div class="callout goal"><strong>Images are the distribution unit.</strong> An image is a stack of read-only layers, each representing a Dockerfile instruction. The content-addressable storage model (every blob keyed by SHA-256) enables deduplication, integrity verification, and efficient distribution.</div>

    <table>
      <thead><tr><th>Concept</th><th>What It Is</th><th>Key Property</th></tr></thead>
      <tbody>
        <tr><td>Layer</td><td>Filesystem diff (tar.gz) from one instruction</td><td>Immutable, content-addressed (SHA-256). Shared across images.</td></tr>
        <tr><td>Image Manifest</td><td>JSON listing layer digests + config</td><td>The "recipe" ‚Äî tells the runtime which layers to stack in what order.</td></tr>
        <tr><td>Image Config</td><td>JSON with env vars, entrypoint, exposed ports</td><td>Runtime metadata. Not a layer ‚Äî doesn't contain filesystem data.</td></tr>
        <tr><td>Tag</td><td>Human-readable pointer (e.g., "nginx:1.25")</td><td>MUTABLE ‚Äî "latest" can point to different digests over time. Not trustworthy for pinning.</td></tr>
        <tr><td>Digest</td><td>SHA-256 of the manifest (e.g., sha256:abc123...)</td><td>IMMUTABLE ‚Äî changing 1 byte changes the digest. Use for production pinning.</td></tr>
      </tbody>
    </table>

    <div class="callout decision"><strong>Why content-addressable storage?</strong> If two Dockerfiles both start with <code>FROM ubuntu:22.04</code>, the Ubuntu base layer is stored ONCE in the registry, regardless of how many images reference it. The layer's address IS its content hash ‚Äî deduplication is automatic. This is what makes Docker Hub viable: billions of pulls but most are fetching layers that are already locally cached. A <code>docker pull</code> first downloads the manifest (small JSON), then checks each layer against the local store. Only missing layers are downloaded.</div>

    <div class="schema"><span class="comment">// Image manifest structure (OCI Image Spec)</span>
{
  "schemaVersion": 2,
  "mediaType": "application/vnd.oci.image.manifest.v1+json",
  "config": {
    "digest": <span class="pk">"sha256:a1b2c3..."</span>,     <span class="comment">// image config blob</span>
    "size": 7023
  },
  "layers": [
    { "digest": <span class="fk">"sha256:d4e5f6..."</span>, "size": 32654321 },  <span class="comment">// ubuntu base (~30MB)</span>
    { "digest": <span class="fk">"sha256:g7h8i9..."</span>, "size": 1847291 },   <span class="comment">// apt-get install nginx</span>
    { "digest": <span class="fk">"sha256:j0k1l2..."</span>, "size": 4521 }       <span class="comment">// COPY nginx.conf</span>
  ]
}</div>

    <div class="callout decision"><strong>Build cache is layer-granular.</strong> When rebuilding an image, Docker checks: "has this instruction changed?" If <code>RUN apt-get install nginx</code> hasn't changed AND its parent layer is the same, the cached layer is reused. This is why Dockerfiles should order instructions by change frequency: base OS first (changes rarely), dependencies next (changes weekly), application code last (changes every commit). A well-ordered Dockerfile rebuilds in seconds because only the final COPY layer is new.</div>

    <!-- DD3: Container Networking -->
    <div class="sub" id="dd-networking">Deep Dive 3: Container Networking (~8 min)</div>

    <div class="callout goal"><strong>Each container needs an isolated network that can still communicate with the outside world.</strong> Docker creates a virtual Ethernet pair (veth) ‚Äî one end inside the container's network namespace, one end on the host's bridge. The bridge acts like a virtual switch connecting all containers.</div>

    <div class="svg-diagram">
      <span class="dia-title">Bridge Networking</span>
      <svg viewBox="0 0 780 280" xmlns="http://www.w3.org/2000/svg" style="font-family:'DM Sans',sans-serif">
        <defs>
          <marker id="d3" markerWidth="7" markerHeight="5" refX="7" refY="2.5" orient="auto"><path d="M0,0 L7,2.5 L0,5" fill="none" stroke="#6e7681" stroke-width="1"/></marker>
        </defs>

        <!-- Container A -->
        <rect x="60" y="20" width="180" height="50" rx="6" fill="#161b22" stroke="#58a6ff" stroke-width="1.5"/>
        <text x="150" y="40" fill="#58a6ff" font-size="10" text-anchor="middle" font-weight="600">Container A</text>
        <text x="150" y="56" fill="#6e7681" font-size="8" text-anchor="middle" font-family="'JetBrains Mono',monospace">eth0: 172.17.0.2</text>

        <!-- Container B -->
        <rect x="300" y="20" width="180" height="50" rx="6" fill="#161b22" stroke="#58a6ff" stroke-width="1.5"/>
        <text x="390" y="40" fill="#58a6ff" font-size="10" text-anchor="middle" font-weight="600">Container B</text>
        <text x="390" y="56" fill="#6e7681" font-size="8" text-anchor="middle" font-family="'JetBrains Mono',monospace">eth0: 172.17.0.3</text>

        <!-- Host -->
        <rect x="560" y="20" width="180" height="50" rx="6" fill="#161b22" stroke="#d29922" stroke-width="1.5"/>
        <text x="650" y="40" fill="#d29922" font-size="10" text-anchor="middle" font-weight="600">Host</text>
        <text x="650" y="56" fill="#6e7681" font-size="8" text-anchor="middle" font-family="'JetBrains Mono',monospace">eth0: 10.0.0.5</text>

        <!-- Veth pairs -->
        <line x1="150" y1="70" x2="150" y2="120" stroke="#bc8cff" stroke-width="1.2" marker-end="url(#d3)"/>
        <text x="170" y="98" fill="#bc8cff" font-size="7">veth pair</text>
        <line x1="390" y1="70" x2="390" y2="120" stroke="#bc8cff" stroke-width="1.2" marker-end="url(#d3)"/>
        <text x="410" y="98" fill="#bc8cff" font-size="7">veth pair</text>

        <!-- Bridge -->
        <rect x="60" y="120" width="460" height="50" rx="8" fill="rgba(63,185,80,.04)" stroke="#3fb950" stroke-width="1.5"/>
        <text x="290" y="142" fill="#3fb950" font-size="11" text-anchor="middle" font-weight="600">docker0 bridge (172.17.0.1)</text>
        <text x="290" y="160" fill="#6e7681" font-size="8" text-anchor="middle">(virtual L2 switch)</text>

        <!-- NAT/iptables -->
        <line x1="520" y1="145" x2="560" y2="145" stroke="#d29922" stroke-width="1.2" marker-end="url(#d3)"/>
        <text x="540" y="138" fill="#d29922" font-size="7" text-anchor="middle">NAT</text>

        <!-- Host to bridge connection -->
        <line x1="650" y1="70" x2="650" y2="120" stroke="#d29922" stroke-width="1" stroke-dasharray="4 2"/>
        <rect x="560" y="120" width="180" height="50" rx="8" fill="rgba(210,153,34,.04)" stroke="rgba(210,153,34,.2)" stroke-width="1"/>
        <text x="650" y="142" fill="#d29922" font-size="9" text-anchor="middle" font-weight="600">iptables / NAT</text>
        <text x="650" y="158" fill="#6e7681" font-size="8" text-anchor="middle">MASQUERADE outbound</text>

        <!-- Internet -->
        <line x1="650" y1="170" x2="650" y2="200" stroke="#6e7681" stroke-width="1" marker-end="url(#d3)"/>
        <rect x="580" y="200" width="140" height="30" rx="15" fill="#161b22" stroke="var(--border)" stroke-width="1"/>
        <text x="650" y="219" fill="#6e7681" font-size="9" text-anchor="middle">Internet</text>

        <!-- Legend -->
        <rect x="60" y="245" width="460" height="24" rx="4" fill="rgba(255,255,255,.01)" stroke="var(--border)" stroke-width=".5"/>
        <text x="290" y="260" fill="#6e7681" font-size="7" text-anchor="middle">Containers talk via bridge (L2). Outbound traffic uses NAT through host. Inbound uses port mapping (iptables DNAT).</text>
      </svg>
    </div>

    <table>
      <thead><tr><th>Network Mode</th><th>How It Works</th><th>Use Case</th></tr></thead>
      <tbody>
        <tr><td>bridge (default)</td><td>Container on docker0 bridge, NAT to host. Each gets 172.17.0.x IP.</td><td>Standard isolation. Containers communicate via bridge, reach internet via NAT.</td></tr>
        <tr><td>host</td><td>No network namespace. Container shares host's network stack directly.</td><td>Maximum network performance (no NAT overhead). Zero isolation.</td></tr>
        <tr><td>none</td><td>No networking. Only loopback interface.</td><td>Batch processing, security-sensitive workloads that should never access network.</td></tr>
        <tr><td>overlay</td><td>VXLAN tunnels between hosts. Containers on different hosts get same virtual network.</td><td>Docker Swarm / multi-host networking. Containers on different machines communicate as if local.</td></tr>
        <tr><td>macvlan</td><td>Container gets its own MAC address on physical network.</td><td>Legacy apps that need to appear as physical devices on the LAN.</td></tr>
      </tbody>
    </table>

    <div class="callout decision"><strong>Port mapping (-p 8080:80) uses iptables DNAT.</strong> When you publish a port, Docker adds an iptables rule: traffic hitting host:8080 is destination-NAT'd to container_ip:80. This is why published ports are visible to the entire network (not just localhost). For production, a reverse proxy (Nginx, Traefik) in front is preferred over raw port mapping ‚Äî it handles TLS, routing, and load balancing.</div>

    <!-- DD4: Data Model & Storage -->
    <div class="sub" id="dd-data">Deep Dive 4: Data Model &amp; Storage (~5 min)</div>

    <div class="callout goal"><strong>OverlayFS is the key innovation.</strong> It stacks multiple read-only layers (from the image) and adds one writable layer on top. Reads fall through layers until the file is found. Writes go to the top layer only (copy-on-write). This means 500 containers from the same image share all base layers ‚Äî massive space savings.</div>

    <div class="svg-diagram">
      <span class="dia-title">OverlayFS Layer Stack</span>
      <svg viewBox="0 0 780 260" xmlns="http://www.w3.org/2000/svg" style="font-family:'DM Sans',sans-serif">
        <!-- Writable layer -->
        <rect x="140" y="16" width="500" height="44" rx="6" fill="rgba(248,81,73,.04)" stroke="#f85149" stroke-width="1.5"/>
        <text x="160" y="35" fill="#f85149" font-size="10" font-weight="600">Container writable layer (upperdir)</text>
        <text x="160" y="50" fill="#6e7681" font-size="8">Per-container, ephemeral. Writes land here via copy-on-write.</text>
        <text x="660" y="42" fill="#f85149" font-size="7" text-anchor="end">‚Üê WRITES</text>

        <!-- Divider -->
        <line x1="140" y1="66" x2="640" y2="66" stroke="var(--border)" stroke-width="1" stroke-dasharray="4 2"/>
        <text x="660" y="70" fill="#6e7681" font-size="7">read-only below</text>

        <!-- Layer 3 -->
        <rect x="140" y="76" width="500" height="40" rx="5" fill="rgba(88,166,255,.04)" stroke="rgba(88,166,255,.2)" stroke-width="1"/>
        <text x="160" y="93" fill="#d29922" font-size="9" font-weight="600">Layer 3: COPY app.py</text>
        <text x="160" y="107" fill="#6e7681" font-size="8">Read-only. From image build.</text>

        <!-- Layer 2 -->
        <rect x="140" y="122" width="500" height="40" rx="5" fill="rgba(88,166,255,.04)" stroke="rgba(88,166,255,.2)" stroke-width="1"/>
        <text x="160" y="139" fill="#d29922" font-size="9" font-weight="600">Layer 2: RUN pip install</text>
        <text x="160" y="153" fill="#6e7681" font-size="8">Read-only. Shared across containers from same image.</text>

        <!-- Layer 1 -->
        <rect x="140" y="168" width="500" height="40" rx="5" fill="rgba(88,166,255,.04)" stroke="rgba(88,166,255,.2)" stroke-width="1"/>
        <text x="160" y="185" fill="#d29922" font-size="9" font-weight="600">Layer 1: FROM python:3.12</text>
        <text x="160" y="199" fill="#6e7681" font-size="8">Read-only. Shared across different images too.</text>

        <!-- COW annotation -->
        <rect x="140" y="220" width="500" height="28" rx="5" fill="rgba(210,153,34,.04)" stroke="rgba(210,153,34,.15)" stroke-width="1"/>
        <text x="390" y="238" fill="#d29922" font-size="8" text-anchor="middle">Copy-on-write: first write copies file up from lower layer, then modifies in writable layer</text>
      </svg>
    </div>

    <div class="callout decision"><strong>Why OverlayFS over device-mapper or AUFS?</strong> OverlayFS is in the mainline Linux kernel (since 3.18), requires no special setup, and has the best performance for the Docker workload (many small reads, few writes). AUFS was Docker's original choice but was never merged into mainline (requires a patched kernel). Device-mapper works but has higher metadata overhead and slower container startup for large images. Btrfs and ZFS offer snapshots but require formatting the entire disk. OverlayFS works on any ext4/xfs filesystem ‚Äî zero prerequisites.</div>

    <div class="callout tip"><strong>Volumes vs bind mounts:</strong> Container writable layers are EPHEMERAL ‚Äî they're deleted with the container. For persistent data (databases, uploads), use volumes. A Docker volume is a directory on the host (<code>/var/lib/docker/volumes/{name}/_data</code>) mounted directly into the container, bypassing OverlayFS. This means: (1) I/O goes directly to the host filesystem (no CoW overhead), (2) data survives container deletion, (3) volumes can be shared between containers. Bind mounts are similar but mount an arbitrary host path ‚Äî useful for development (mount source code into container).</div>

  </div>
</div>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê PHASE 5: CROSS-CUTTING ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<div class="phase" id="p5">
  <div class="phase-header" onclick="this.closest('.phase').classList.toggle('collapsed')">
    <span class="phase-number" style="background:var(--phase5);color:var(--bg)">05</span>
    <span class="phase-title">Cross-Cutting Concerns</span><span class="phase-time">10‚Äì12 min</span>
    <svg class="phase-chevron" viewBox="0 0 20 20" fill="currentColor"><path d="M6.3 6.3a1 1 0 011.4 0L10 8.6l2.3-2.3a1 1 0 111.4 1.4l-3 3a1 1 0 01-1.4 0l-3-3a1 1 0 010-1.4z"/></svg>
  </div>
  <div class="phase-body">

    <div class="sub">Storage Architecture Summary</div>
    <div class="callout goal"><strong>What goes where and why.</strong> Each data store is chosen for its access pattern ‚Äî not by default.</div>
    <table>
      <thead><tr><th>Data</th><th>Store</th><th>Why This Store</th></tr></thead>
      <tbody>
        <tr><td>Image layers</td><td style="color:var(--accent-cyan)">OverlayFS (/var/lib/docker/overlay2)</td><td>Read-only, content-addressed by SHA-256. Shared across containers. Deduped on disk automatically.</td></tr>
        <tr><td>Container writable layer</td><td style="color:var(--accent-cyan)">OverlayFS (upperdir, per-container)</td><td>Ephemeral. Copy-on-write. Deleted with container. Not for persistent data.</td></tr>
        <tr><td>Volumes</td><td style="color:var(--accent-cyan)">Host filesystem (direct mount)</td><td>Persistent data (DBs, uploads). Bypasses OverlayFS for native I/O performance. Survives container lifecycle.</td></tr>
        <tr><td>Registry blobs</td><td style="color:var(--accent-cyan)">S3 / object storage</td><td>Petabyte scale, content-addressed. CDN-friendly. Layer blobs are immutable ‚Äî perfect for object storage.</td></tr>
        <tr><td>Registry metadata</td><td style="color:var(--accent-cyan)">PostgreSQL</td><td>Tag ‚Üí digest mapping, repository permissions, user accounts. Relational with ACID for tag updates.</td></tr>
        <tr><td>Container state</td><td style="color:var(--accent-cyan)">JSON on disk + containerd DB (bbolt)</td><td>Container config, status, restart policy. Local to host. Low volume ‚Äî no distributed DB needed.</td></tr>
      </tbody>
    </table>

    <div class="sub" id="failures">Failure Scenarios</div>
    <div class="failure-row"><span class="scenario">Docker daemon (dockerd) crashes</span><span class="mitigation">Containers keep running ‚Äî containerd-shim reparented them from dockerd. This is the entire purpose of the shim architecture: daemon restarts (upgrades, crashes) don't kill running containers. Containerd manages lifecycle independently.</span></div>
    <div class="failure-row"><span class="scenario">Container OOM (exceeds memory limit)</span><span class="mitigation">Linux OOM killer terminates the container's processes. Cgroup memory.max is a hard limit. Docker reports OOM exit code (137). Restart policy (--restart=on-failure) can auto-restart. Root cause: application memory leak or insufficient limit.</span></div>
    <div class="failure-row"><span class="scenario">Disk full (image layers consume all space)</span><span class="mitigation">`docker system prune` removes unused images, containers, networks, and build cache. In production, set storage limits and monitor /var/lib/docker disk usage. Dangling images (untagged) are the biggest offender.</span></div>
    <div class="failure-row"><span class="scenario">Registry unavailable during deploy</span><span class="mitigation">Containers already running are unaffected (images are cached locally). New deployments fail. Mitigation: pre-pull images, use local registry mirrors, or Harbor as a pull-through cache. The runtime never phones home to the registry.</span></div>
    <div class="failure-row"><span class="scenario">Container escape (attacker breaks out of namespace)</span><span class="mitigation">Defense in depth: (1) seccomp profile blocks dangerous syscalls (300+ blocked by default), (2) AppArmor/SELinux restricts filesystem access, (3) USER namespace maps root to unprivileged host user, (4) drop capabilities (CAP_SYS_ADMIN, CAP_NET_RAW). If all fail, the shared kernel is the weak point ‚Äî use gVisor or Kata for untrusted workloads.</span></div>
    <div class="failure-row"><span class="scenario">Image supply chain attack (malicious base image)</span><span class="mitigation">Docker Content Trust (DCT) uses Notary for image signing. Only signed images can be pulled when DCT is enabled. Pin images by digest (sha256:...) not tag. Scan images with Trivy/Grype before deployment. Use minimal base images (distroless, Alpine) to reduce attack surface.</span></div>

    <div class="sub">Security Architecture</div>
    <div class="callout decision"><strong>Security &amp; Access Control.</strong> Container security is defense in depth ‚Äî no single layer is sufficient. Namespaces provide visibility isolation (container can't see host processes). Cgroups provide resource isolation (container can't consume all host RAM). Seccomp filters block 300+ dangerous syscalls by default (no kernel module loading, no rebooting, no raw disk access). Capabilities are dropped: even root inside the container can't do most privileged operations. AppArmor/SELinux provides mandatory access control ‚Äî a container can only access paths in its profile. The USER namespace maps container root (UID 0) to an unprivileged host user (UID 100000+), so even a container escape lands as a non-root user. For truly untrusted workloads (multi-tenant SaaS), use gVisor (user-space kernel that intercepts syscalls) or Kata Containers (lightweight VM per container) for hardware-level isolation.</div>

    <div class="sub">Scalability</div>
    <div class="callout tip"><strong>Scalability.</strong> Per-host scaling: a single Linux host can run 500+ containers with proper resource limits. The bottleneck is typically I/O (OverlayFS metadata for many layers) and network (iptables rules scale O(n) with containers ‚Äî at 1000+ containers, use ipvs instead). Memory overhead per container is near-zero (shared kernel, shared image layers) ‚Äî only the application's memory footprint matters. Registry scaling: S3 blob storage scales infinitely. The metadata DB (PostgreSQL) is the bottleneck ‚Äî sharded by repository namespace. CDN handles read amplification. Docker Hub processes billions of pulls by serving layer blobs directly from CDN edge, with PostgreSQL only handling manifest lookups and authentication.</div>

    <div class="sub">Monitoring &amp; SLOs</div>
    <div class="callout tip"><strong>Monitoring &amp; SLOs.</strong> Per-container metrics via cgroups: CPU usage (cpu.stat), memory usage (memory.current vs memory.max), I/O bytes (io.stat), network bytes (from /proc/net/dev inside net namespace). Docker exposes these via the stats API. Key SLOs: container startup p99 &lt;2 seconds, image pull p95 &lt;30 seconds (cold, 500MB), registry availability 99.95%. Alerting: OOM kills (indicates undersized limits or memory leaks), disk usage &gt;80% on /var/lib/docker, container restart loops (CrashLoopBackOff indicates application bugs). For orchestrated environments, cAdvisor exports metrics to Prometheus, and kubelet enforces pod-level resource quotas.</div>

  </div>
</div>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê PHASE 6: WRAP-UP ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<div class="phase" id="p6">
  <div class="phase-header" onclick="this.closest('.phase').classList.toggle('collapsed')">
    <span class="phase-number" style="background:var(--phase6);color:var(--bg)">06</span>
    <span class="phase-title">Wrap-Up &amp; Evolution</span><span class="phase-time">3‚Äì5 min</span>
    <svg class="phase-chevron" viewBox="0 0 20 20" fill="currentColor"><path d="M6.3 6.3a1 1 0 011.4 0L10 8.6l2.3-2.3a1 1 0 111.4 1.4l-3 3a1 1 0 01-1.4 0l-3-3a1 1 0 010-1.4z"/></svg>
  </div>
  <div class="phase-body">

    <div class="sub" id="evolution">What I'd Build Next</div>
    <ul class="items">
      <li><strong>Multi-host orchestration (Kubernetes):</strong> Scheduling containers across a cluster. Pod abstraction (co-located containers), service discovery, rolling deploys, auto-scaling based on metrics.</li>
      <li><strong>Image build optimization (BuildKit):</strong> Parallel layer builds (independent RUN commands execute concurrently), cache mounts (reuse pip/npm cache across builds), multi-stage builds to minimize final image size.</li>
      <li><strong>Rootless containers:</strong> Run the entire Docker daemon as a non-root user. User namespaces map container root to unprivileged host UID. Eliminates the biggest attack vector (Docker socket = root access).</li>
      <li><strong>WebAssembly (WASM) containers:</strong> WASM runtimes (WasmEdge) as an alternative to Linux containers. Microsecond startup, 1MB memory footprint, sandbox-by-default. Ideal for edge computing and serverless.</li>
      <li><strong>Image streaming (lazy pulling):</strong> Start the container before the full image is downloaded. Pull layers on-demand as files are accessed (eStargz, Nydus). Reduces cold-start from 30 seconds to &lt;2 seconds for large images.</li>
      <li><strong>Supply chain security (SBOM + attestation):</strong> Every image includes a Software Bill of Materials listing every package. Signed attestations prove the image was built from a specific commit by a specific CI pipeline. SLSA framework compliance.</li>
    </ul>

    <div class="callout say">"The core Docker design ‚Äî namespaces for isolation, cgroups for limits, OverlayFS for layered storage, content-addressable registry for distribution ‚Äî has been remarkably stable. The evolution is happening at the edges: better security (rootless, gVisor), faster startup (WASM, lazy pulling), and stronger supply chain guarantees (SBOM, Sigstore)."</div>

  </div>
</div>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê PHASE 7: INTERVIEW Q&A ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<div class="phase" id="p7">
  <div class="phase-header" onclick="this.closest('.phase').classList.toggle('collapsed')">
    <span class="phase-number" style="background:var(--accent-cyan)">07</span>
    <span class="phase-title">Interview Q&amp;A</span><span class="phase-time">Practice</span>
    <svg class="phase-chevron" viewBox="0 0 20 20" fill="currentColor"><path d="M6.3 6.3a1 1 0 011.4 0L10 8.6l2.3-2.3a1 1 0 111.4 1.4l-3 3a1 1 0 01-1.4 0l-3-3a1 1 0 010-1.4z"/></svg>
  </div>
  <div class="phase-body">
    <div class="callout say">"Here are the hardest questions an interviewer would ask about this design, and how to answer them. Each answer demonstrates deep understanding of the tradeoffs, not just surface knowledge."</div>

    <div style="margin:8px 0;">
      <div style="display:flex;gap:10px;align-items:flex-start;margin-bottom:8px">
        <span style="font-family:var(--font-mono);font-size:10px;padding:3px 8px;border-radius:4px;background:rgba(248,81,73,.1);color:var(--accent-red);font-weight:600;flex-shrink:0">Q1</span>
        <p style="color:var(--text);font-size:13.5px;font-weight:600;line-height:1.5;margin:0">What's the difference between a container and a VM? When would you still choose a VM?</p>
      </div>
      <div style="display:flex;gap:10px;align-items:flex-start">
        <span style="font-family:var(--font-mono);font-size:10px;padding:3px 8px;border-radius:4px;background:rgba(63,185,80,.1);color:var(--accent-green);font-weight:600;flex-shrink:0">A</span>
        <p style="color:var(--text-muted);font-size:13px;line-height:1.65;margin:0">A container is a process isolated by kernel namespaces, sharing the host kernel. A VM runs a complete guest kernel on a hypervisor, with hardware-level isolation. Containers win on: startup speed (&lt;1s vs 30-60s), density (500/host vs 50), image size (MBs vs GBs), and resource efficiency (shared kernel, shared base layers). VMs win on: isolation strength (hardware boundary ‚Äî a kernel exploit in a container escapes to the host, in a VM it doesn't), running different OSes (Windows on Linux host), and regulatory compliance (some security standards require hardware isolation). The practical rule: containers for your own code running in a trusted environment, VMs for untrusted multi-tenant workloads or when you need a different kernel version. The middle ground is Kata Containers or Firecracker ‚Äî lightweight VMs that boot in &lt;1 second, giving VM-level isolation with near-container performance.</p>
      </div>
    </div>

    <div style="margin:18px 0;">
      <div style="display:flex;gap:10px;align-items:flex-start;margin-bottom:8px">
        <span style="font-family:var(--font-mono);font-size:10px;padding:3px 8px;border-radius:4px;background:rgba(248,81,73,.1);color:var(--accent-red);font-weight:600;flex-shrink:0">Q2</span>
        <p style="color:var(--text);font-size:13.5px;font-weight:600;line-height:1.5;margin:0">Why does Docker need containerd AND runc? Why not just have the daemon create containers directly?</p>
      </div>
      <div style="display:flex;gap:10px;align-items:flex-start">
        <span style="font-family:var(--font-mono);font-size:10px;padding:3px 8px;border-radius:4px;background:rgba(63,185,80,.1);color:var(--accent-green);font-weight:600;flex-shrink:0">A</span>
        <p style="color:var(--text-muted);font-size:13px;line-height:1.65;margin:0">This is separation of concerns driven by hard operational requirements. Original Docker (pre-1.11) was monolithic ‚Äî the daemon did everything. Problem: restarting the daemon (for upgrades) killed ALL running containers. Splitting into layers solved this: (1) runc creates the container process and exits ‚Äî it's a short-lived CLI tool, not a daemon. (2) containerd-shim reparents the container process, so it survives daemon restarts. (3) containerd manages the lifecycle and talks to the shim via gRPC. (4) dockerd provides the user-facing API and builds on top of containerd. The result: you can upgrade dockerd without touching running containers. Kubernetes also benefits ‚Äî it talks to containerd directly (CRI), bypassing dockerd entirely. This is why Docker "removed" Dockershim from Kubernetes: K8s never needed dockerd, just containerd.</p>
      </div>
    </div>

    <div style="margin:18px 0;">
      <div style="display:flex;gap:10px;align-items:flex-start;margin-bottom:8px">
        <span style="font-family:var(--font-mono);font-size:10px;padding:3px 8px;border-radius:4px;background:rgba(248,81,73,.1);color:var(--accent-red);font-weight:600;flex-shrink:0">Q3</span>
        <p style="color:var(--text);font-size:13.5px;font-weight:600;line-height:1.5;margin:0">How does copy-on-write work in OverlayFS, and what are its performance implications?</p>
      </div>
      <div style="display:flex;gap:10px;align-items:flex-start">
        <span style="font-family:var(--font-mono);font-size:10px;padding:3px 8px;border-radius:4px;background:rgba(63,185,80,.1);color:var(--accent-green);font-weight:600;flex-shrink:0">A</span>
        <p style="color:var(--text-muted);font-size:13px;line-height:1.65;margin:0">OverlayFS has two directories: lowerdir (read-only image layers, stacked) and upperdir (writable, per-container). On read: the kernel checks upperdir first, then falls through lower layers until the file is found. On write: if the file exists in a lower layer, it's copied up to upperdir first (copy-on-write), then modified in upperdir. New files go directly to upperdir. On delete: a "whiteout" file is created in upperdir that hides the lower layer file. Performance implications: reads are fast (kernel caches the lookup path). First write to an existing file is slow (must copy the entire file up, even if modifying 1 byte ‚Äî this is per-file, not per-block). Subsequent writes to the same file are fast (already in upperdir). This means: containers that read heavily are great. Containers that modify large files repeatedly (databases) should use volumes, not the container filesystem. For databases, always use a Docker volume ‚Äî it bypasses OverlayFS entirely for native filesystem performance.</p>
      </div>
    </div>

    <div style="margin:18px 0;">
      <div style="display:flex;gap:10px;align-items:flex-start;margin-bottom:8px">
        <span style="font-family:var(--font-mono);font-size:10px;padding:3px 8px;border-radius:4px;background:rgba(248,81,73,.1);color:var(--accent-red);font-weight:600;flex-shrink:0">Q4</span>
        <p style="color:var(--text);font-size:13.5px;font-weight:600;line-height:1.5;margin:0">How would you design Docker Hub to handle billions of image pulls per day?</p>
      </div>
      <div style="display:flex;gap:10px;align-items:flex-start">
        <span style="font-family:var(--font-mono);font-size:10px;padding:3px 8px;border-radius:4px;background:rgba(63,185,80,.1);color:var(--accent-green);font-weight:600;flex-shrink:0">A</span>
        <p style="color:var(--text-muted);font-size:13px;line-height:1.65;margin:0">The key insight is that a "pull" is mostly blob (layer) downloads, and blobs are immutable content-addressed data ‚Äî perfect for CDN. Architecture: (1) Client requests manifest from API server (PostgreSQL lookup: tag ‚Üí digest ‚Üí manifest). (2) Manifest lists layer digests. Client checks local cache ‚Äî usually 80% of layers are already present. (3) Missing layers are fetched via CDN (CloudFront/Cloudflare). The CDN key IS the SHA-256 digest ‚Äî same layer, same key, regardless of which image references it. (4) S3 stores all blobs. CDN cache hit rate is extremely high because popular base images (python, node, ubuntu) are pulled millions of times. The PostgreSQL metadata DB is the bottleneck ‚Äî sharded by repository name. Rate limiting per user/IP prevents CI systems from overwhelming the registry. The massive deduplication (ubuntu:22.04 base layer stored once, referenced by millions of images) is what makes the economics work.</p>
      </div>
    </div>

    <div style="margin:18px 0;">
      <div style="display:flex;gap:10px;align-items:flex-start;margin-bottom:8px">
        <span style="font-family:var(--font-mono);font-size:10px;padding:3px 8px;border-radius:4px;background:rgba(248,81,73,.1);color:var(--accent-red);font-weight:600;flex-shrink:0">Q5</span>
        <p style="color:var(--text);font-size:13.5px;font-weight:600;line-height:1.5;margin:0">A container running as root inside ‚Äî is it root on the host? How do you secure this?</p>
      </div>
      <div style="display:flex;gap:10px;align-items:flex-start">
        <span style="font-family:var(--font-mono);font-size:10px;padding:3px 8px;border-radius:4px;background:rgba(63,185,80,.1);color:var(--accent-green);font-weight:600;flex-shrink:0">A</span>
        <p style="color:var(--text-muted);font-size:13px;line-height:1.65;margin:0">By default, yes ‚Äî root in the container IS root on the host (UID 0). If a container escape exploit exists, the attacker has root on the host machine. This is Docker's biggest security criticism. Mitigations, in order of impact: (1) USER namespace remapping: configure Docker to map container UID 0 to host UID 100000. Now even a container escape lands as an unprivileged user. This is "rootless Docker" and is the single most effective security control. (2) Don't run as root in the container: Dockerfile should include `USER nonroot`. Most applications don't need root. (3) Drop capabilities: Docker drops most Linux capabilities by default (CAP_SYS_ADMIN, CAP_NET_RAW, etc.). Even root inside can't load kernel modules or access raw sockets. (4) Seccomp profile: blocks 300+ dangerous syscalls. (5) Read-only filesystem (--read-only): prevents writing to container filesystem at all. (6) For truly untrusted code: use gVisor (intercepts all syscalls in userspace) or Kata (lightweight VM). The defense-in-depth approach means a container escape requires bypassing ALL of these layers.</p>
      </div>
    </div>

  </div>
</div>

</main>
</body>
</html>
