<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Design Uber ‚Äî Worked Example</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&family=DM+Sans:ital,wght@0,400;0,500;0,600;0,700&family=Fraunces:ital,opsz,wght@0,9..144,700;1,9..144,400&display=swap" rel="stylesheet">
<style>
  :root {
    --bg: #0e1117;
    --surface: #161b22;
    --surface-raised: #1c2129;
    --border: #2d333b;
    --border-light: #373e47;
    --text: #e6edf3;
    --text-muted: #8b949e;
    --text-dim: #6e7681;
    --accent-blue: #58a6ff;
    --accent-green: #3fb950;
    --accent-orange: #d29922;
    --accent-red: #f85149;
    --accent-purple: #bc8cff;
    --accent-cyan: #39d2c0;
    --accent-yellow: #e3b341;
    --phase1: #58a6ff;
    --phase2: #d29922;
    --phase3: #3fb950;
    --phase4: #f85149;
    --phase5: #bc8cff;
    --phase6: #39d2c0;
    --nav-width: 270px;
    --font-body: 'DM Sans', -apple-system, sans-serif;
    --font-mono: 'JetBrains Mono', monospace;
    --font-display: 'Fraunces', Georgia, serif;
  }
  * { margin: 0; padding: 0; box-sizing: border-box; }
  html { scroll-behavior: smooth; scroll-padding-top: 24px; }
  body { font-family: var(--font-body); background: var(--bg); color: var(--text); font-size: 14px; line-height: 1.6; }

  /* ‚îÄ‚îÄ Nav ‚îÄ‚îÄ */
  nav {
    position: fixed; top: 0; left: 0; width: var(--nav-width); height: 100vh;
    background: var(--surface); border-right: 1px solid var(--border);
    padding: 24px 0; overflow-y: auto; z-index: 100; display: flex; flex-direction: column;
  }
  nav .logo { padding: 0 20px 20px; border-bottom: 1px solid var(--border); margin-bottom: 16px; }
  nav .logo h1 { font-family: var(--font-display); font-size: 18px; font-weight: 700; color: var(--text); letter-spacing: -0.02em; line-height: 1.3; }
  nav .logo span { display: block; font-family: var(--font-body); font-size: 11px; color: var(--text-dim); margin-top: 4px; font-weight: 400; text-transform: uppercase; letter-spacing: 0.08em; }
  .nav-section-label { font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.1em; color: var(--text-dim); padding: 12px 20px 6px; }
  nav a { display: flex; align-items: center; gap: 10px; padding: 7px 20px; color: var(--text-muted); text-decoration: none; font-size: 13px; font-weight: 500; transition: all 0.15s; border-left: 2px solid transparent; }
  nav a:hover { color: var(--text); background: var(--surface-raised); }
  nav a.active { color: var(--text); border-left-color: var(--accent-blue); background: rgba(88,166,255,0.06); }
  .nav-dot { width: 7px; height: 7px; border-radius: 50%; flex-shrink: 0; }
  .nav-time { margin-left: auto; font-family: var(--font-mono); font-size: 10px; color: var(--text-dim); background: var(--surface-raised); padding: 1px 6px; border-radius: 3px; }

  /* ‚îÄ‚îÄ Main ‚îÄ‚îÄ */
  main { margin-left: var(--nav-width); padding: 32px 48px 120px; max-width: 960px; }

  /* ‚îÄ‚îÄ Section blocks ‚îÄ‚îÄ */
  .phase { margin-bottom: 40px; border: 1px solid var(--border); border-radius: 10px; overflow: hidden; background: var(--surface); }
  .phase-header { display: flex; align-items: center; gap: 14px; padding: 16px 20px; cursor: pointer; user-select: none; transition: background 0.15s; }
  .phase-header:hover { background: var(--surface-raised); }
  .phase-number { font-family: var(--font-mono); font-size: 11px; font-weight: 600; padding: 3px 8px; border-radius: 4px; color: var(--bg); flex-shrink: 0; }
  .phase-title { font-family: var(--font-display); font-size: 17px; font-weight: 700; flex: 1; }
  .phase-time { font-family: var(--font-mono); font-size: 12px; color: var(--text-muted); flex-shrink: 0; }
  .phase-chevron { width: 20px; height: 20px; color: var(--text-dim); transition: transform 0.25s ease; flex-shrink: 0; }
  .phase.collapsed .phase-chevron { transform: rotate(-90deg); }
  .phase.collapsed .phase-body { display: none; }
  .phase-body { padding: 0 20px 20px; border-top: 1px solid var(--border); }

  /* ‚îÄ‚îÄ Callouts ‚îÄ‚îÄ */
  .callout { margin: 14px 0; padding: 12px 16px; border-radius: 0 6px 6px 0; font-size: 13px; line-height: 1.6; }
  .callout.goal { background: rgba(88,166,255,0.05); border-left: 3px solid var(--accent-blue); color: var(--text-muted); }
  .callout.goal strong { color: var(--accent-blue); }
  .callout.say { background: rgba(63,185,80,0.06); border-left: 3px solid var(--accent-green); color: var(--text-muted); }
  .callout.say::before { content: 'üó£Ô∏è '; }
  .callout.tip { background: rgba(210,153,34,0.06); border-left: 3px solid var(--accent-orange); color: var(--text-muted); }
  .callout.tip::before { content: 'üí° '; }
  .callout.decision { background: rgba(248,81,73,0.05); border-left: 3px solid var(--accent-red); color: var(--text-muted); }
  .callout.decision::before { content: '‚öñÔ∏è '; }
  .callout.warn { background: rgba(188,140,255,0.06); border-left: 3px solid var(--accent-purple); color: var(--text-muted); }
  .callout code { background: rgba(255,255,255,0.06); padding: 1px 5px; border-radius: 3px; font-family: var(--font-mono); font-size: 12px; }

  /* ‚îÄ‚îÄ Sub-sections ‚îÄ‚îÄ */
  .sub { font-size: 14px; font-weight: 700; color: var(--accent-cyan); margin: 20px 0 8px; padding-bottom: 6px; border-bottom: 1px solid var(--border); }

  /* ‚îÄ‚îÄ Lists ‚îÄ‚îÄ */
  .items { list-style: none; margin: 10px 0; }
  .items li { position: relative; padding: 5px 0 5px 22px; font-size: 13.5px; line-height: 1.55; color: var(--text-muted); }
  .items li::before { content: '‚Üí'; position: absolute; left: 2px; color: var(--text-dim); font-family: var(--font-mono); font-size: 12px; }
  .items li strong { color: var(--text); font-weight: 600; }

  /* ‚îÄ‚îÄ Tables ‚îÄ‚îÄ */
  table { width: 100%; border-collapse: collapse; font-size: 12.5px; margin: 12px 0; }
  thead th { text-align: left; font-size: 10px; text-transform: uppercase; letter-spacing: 0.08em; color: var(--text-dim); padding: 8px 10px; border-bottom: 1px solid var(--border-light); font-weight: 600; }
  tbody td { padding: 8px 10px; border-bottom: 1px solid var(--border); vertical-align: top; line-height: 1.5; color: var(--text-muted); }
  tbody tr:last-child td { border-bottom: none; }
  tbody td:first-child { font-weight: 600; color: var(--text); font-family: var(--font-mono); font-size: 11.5px; white-space: nowrap; }

  /* ‚îÄ‚îÄ Estimation Grid ‚îÄ‚îÄ */
  .est-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin: 14px 0; }
  .est-card { padding: 12px 14px; border: 1px solid var(--border); border-radius: 8px; background: var(--surface-raised); }
  .est-card .label { font-size: 10px; text-transform: uppercase; letter-spacing: 0.08em; color: var(--text-dim); margin-bottom: 4px; }
  .est-card .value { font-family: var(--font-mono); font-size: 18px; font-weight: 600; color: var(--accent-yellow); }
  .est-card .detail { font-size: 11.5px; color: var(--text-dim); margin-top: 4px; line-height: 1.4; }

  /* ‚îÄ‚îÄ Schema blocks ‚îÄ‚îÄ */
  .schema { background: var(--surface-raised); border: 1px solid var(--border); border-radius: 8px; padding: 14px 16px; margin: 12px 0; font-family: var(--font-mono); font-size: 12px; line-height: 1.7; color: var(--text-muted); overflow-x: auto; white-space: pre; }
  .schema .table-name { color: var(--accent-cyan); font-weight: 600; }
  .schema .pk { color: var(--accent-yellow); }
  .schema .fk { color: var(--accent-purple); }
  .schema .type { color: var(--text-dim); }
  .schema .comment { color: var(--text-dim); font-style: italic; }

  /* ‚îÄ‚îÄ API blocks ‚îÄ‚îÄ */
  .api-block { background: var(--surface-raised); border: 1px solid var(--border); border-radius: 8px; margin: 10px 0; overflow: hidden; }
  .api-method { display: inline-flex; align-items: center; gap: 10px; padding: 8px 14px; font-family: var(--font-mono); font-size: 12px; width: 100%; border-bottom: 1px solid var(--border); }
  .api-method .verb { padding: 2px 8px; border-radius: 4px; font-weight: 600; font-size: 10px; text-transform: uppercase; }
  .api-method .verb.post { background: rgba(63,185,80,0.15); color: var(--accent-green); }
  .api-method .verb.get { background: rgba(88,166,255,0.15); color: var(--accent-blue); }
  .api-method .verb.put { background: rgba(210,153,34,0.15); color: var(--accent-orange); }
  .api-method .verb.ws { background: rgba(188,140,255,0.15); color: var(--accent-purple); }
  .api-method .path { color: var(--text); }
  .api-method .desc { margin-left: auto; color: var(--text-dim); font-size: 11px; font-family: var(--font-body); }
  .api-body { padding: 10px 14px; font-size: 12px; color: var(--text-dim); line-height: 1.55; }

  /* ‚îÄ‚îÄ Architecture flow ‚îÄ‚îÄ */
  .flow-diagram { background: var(--surface-raised); border: 1px solid var(--border); border-radius: 8px; padding: 20px; margin: 14px 0; font-family: var(--font-mono); font-size: 12px; line-height: 2; color: var(--text-muted); overflow-x: auto; white-space: pre; text-align: center; }
  .flow-diagram .highlight { color: var(--accent-cyan); font-weight: 600; }
  .flow-diagram .arrow { color: var(--text-dim); }
  .flow-diagram .label { color: var(--accent-orange); font-size: 10px; }

  /* ‚îÄ‚îÄ Component cards ‚îÄ‚îÄ */
  .comp-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin: 12px 0; }
  .comp-card { padding: 12px 14px; border: 1px solid var(--border); border-radius: 8px; background: var(--surface-raised); }
  .comp-card h4 { font-size: 13px; font-weight: 600; color: var(--text); margin-bottom: 6px; display: flex; align-items: center; gap: 6px; }
  .comp-card h4 .tag { font-family: var(--font-mono); font-size: 9px; padding: 2px 6px; border-radius: 3px; font-weight: 600; }
  .comp-card ul { list-style: none; font-size: 12px; color: var(--text-muted); line-height: 1.55; }
  .comp-card ul li::before { content: '‚Ä¢ '; color: var(--text-dim); }

  /* ‚îÄ‚îÄ Failure scenario ‚îÄ‚îÄ */
  .failure-row { display: flex; gap: 8px; margin: 6px 0; font-size: 12.5px; align-items: flex-start; }
  .failure-row .scenario { color: var(--accent-red); font-weight: 600; min-width: 180px; flex-shrink: 0; }
  .failure-row .mitigation { color: var(--text-muted); }

  /* ‚îÄ‚îÄ Section divider ‚îÄ‚îÄ */
  .divider { text-align: center; margin: 48px 0 32px; position: relative; }
  .divider::before { content: ''; position: absolute; top: 50%; left: 0; right: 0; height: 1px; background: var(--border); }
  .divider span { position: relative; background: var(--bg); padding: 0 16px; font-family: var(--font-mono); font-size: 11px; text-transform: uppercase; letter-spacing: 0.12em; color: var(--text-dim); }

  /* ‚îÄ‚îÄ Responsive ‚îÄ‚îÄ */
  @media (max-width: 900px) {
    nav { display: none; }
    main { margin-left: 0; padding: 20px 16px 80px; }
    .est-grid, .comp-grid { grid-template-columns: 1fr; }
  }
  @media print {
    nav { display: none; }
    main { margin-left: 0; max-width: 100%; }
    .phase.collapsed .phase-body { display: block; }
  }

/* SVG Diagram Styles */
.svg-diagram{margin:14px 0;border:1px solid var(--border);border-radius:8px;background:var(--surface-raised);overflow:hidden;position:relative}
.svg-diagram svg{display:block;width:100%;height:auto}
.svg-diagram .dia-title{position:absolute;top:10px;right:14px;font-family:var(--font-mono);font-size:9px;letter-spacing:.08em;text-transform:uppercase;color:var(--text-dim);opacity:.6}
.svg-node{transition:filter .2s ease}.svg-node:hover{filter:brightness(1.25)}
@keyframes fadeInUp{from{opacity:0;transform:translateY(6px)}to{opacity:1;transform:translateY(0)}}
.svg-diagram[data-anim] .svg-node{animation:fadeInUp .4s ease both}
</style>
</head>
<body>

<nav>
  <div class="logo">
    <h1>Design Uber</h1>
    <span>Worked Example ¬∑ 75 min</span>
  </div>
  <div class="nav-section-label">Interview Phases</div>
  <a href="#p1"><span class="nav-dot" style="background:var(--phase1)"></span>Clarify & Scope<span class="nav-time">5-7m</span></a>
  <a href="#p2"><span class="nav-dot" style="background:var(--phase2)"></span>Estimation<span class="nav-time">3-5m</span></a>
  <a href="#p3"><span class="nav-dot" style="background:var(--phase3)"></span>High-Level Design<span class="nav-time">8-12m</span></a>
  <a href="#p4"><span class="nav-dot" style="background:var(--phase4)"></span>Deep Dives<span class="nav-time">25-30m</span></a>
  <a href="#p5"><span class="nav-dot" style="background:var(--phase5)"></span>Cross-Cutting<span class="nav-time">10-12m</span></a>
  <a href="#p6"><span class="nav-dot" style="background:var(--phase6)"></span>Wrap-Up<span class="nav-time">3-5m</span></a>

  <div class="nav-section-label">Deep Dives</div>
  <a href="#dd-location">Location & Matching</a>
  <a href="#dd-trip">Trip Lifecycle</a>
  <a href="#dd-pricing">Pricing & Surge</a>
  <a href="#dd-data">Data Model & Storage</a>

  <div class="nav-section-label">Reference</div>
  <a href="#apis">API Design</a>
  <a href="#failures">Failure Scenarios</a>
  <a href="#evolution">Evolution</a>
  <a href="#p7"><span class="nav-dot" style="background:var(--accent-cyan)"></span>Interview Q&amp;A<span class="nav-time">Practice</span></a>
</nav>

<main>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê PHASE 1: CLARIFY ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<div class="phase" id="p1">
  <div class="phase-header" onclick="this.closest('.phase').classList.toggle('collapsed')">
    <span class="phase-number" style="background:var(--phase1)">01</span>
    <span class="phase-title">Clarify the Problem & Scope</span>
    <span class="phase-time">5‚Äì7 min</span>
    <svg class="phase-chevron" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.23 7.21a.75.75 0 011.06.02L10 11.168l3.71-3.938a.75.75 0 111.08 1.04l-4.25 4.5a.75.75 0 01-1.08 0l-4.25-4.5a.75.75 0 01.02-1.06z"/></svg>
  </div>
  <div class="phase-body">

    <div class="callout say">"Let me restate ‚Äî we're designing a ride-hailing platform like Uber. A rider requests a ride, the system matches them with a nearby driver, and we track the trip in real-time through pickup, ride, and drop-off. Let me ask a few scoping questions."</div>

    <div class="sub">Questions I'd Ask</div>
    <ul class="items">
            <li><strong>What outcome are we optimizing for?</strong> <em>‚Üí Trip completion rate (rider requests a ride ‚Üí ride finishes successfully). Secondary: rider wait time, driver utilization, ETA accuracy. This tells us the system's job is MATCHING and RELIABILITY, not just speed. A fast match that leads to a cancelled trip is worse than a slower match that completes.</em></li>
      <li><strong>Which side of the marketplace?</strong> Both rider and driver, or just one? <em>‚Üí Assume both.</em></li>
      <li><strong>Ride types?</strong> Just point-to-point, or also shared rides (UberPool), scheduled rides? <em>‚Üí Start with point-to-point only. Mention pool as an extension.</em></li>
      <li><strong>Geography?</strong> Single city, single country, or global? <em>‚Üí Design for multi-city, discuss global as evolution.</em></li>
      <li><strong>Payment?</strong> In scope or out of scope? <em>‚Üí Out of scope for deep dive; acknowledge it exists.</em></li>
      <li><strong>Scale?</strong> Roughly how many concurrent riders/drivers? <em>‚Üí ~100M riders, ~5M drivers globally, ~20M trips/day.</em></li>
      <li><strong>Latency expectations?</strong> How fast should matching happen? <em>‚Üí Rider sees a driver within 5‚Äì10 seconds of requesting.</em></li>
    </ul>

    <div class="sub">Agreed Scope (write on Excalidraw canvas)</div>
    <table>
      <thead><tr><th>In Scope</th><th>Out of Scope</th></tr></thead>
      <tbody>
        <tr><td>Rider requests a ride</td><td>Payment processing</td></tr>
        <tr><td>Driver location tracking</td><td>Driver onboarding / identity verification</td></tr>
        <tr><td>Matching rider ‚Üí driver</td><td>Shared rides (UberPool)</td></tr>
        <tr><td>Real-time trip tracking</td><td>Scheduled rides</td></tr>
        <tr><td>Pricing & surge</td><td>Ratings & reviews</td></tr>
        <tr><td>ETA computation</td><td>Chat/calling between rider & driver</td></tr>
      </tbody>
    </table>

    <div class="sub">Core Use Cases (ranked by priority)</div>
    <ul class="items">
      <li><strong>UC1:</strong> Rider requests ride ‚Üí system matches to nearest available driver ‚Üí driver accepts</li>
      <li><strong>UC2:</strong> Driver continuously reports location ‚Üí system tracks in real-time</li>
      <li><strong>UC3:</strong> Both rider and driver see live trip progress (pickup ‚Üí in-ride ‚Üí drop-off)</li>
      <li><strong>UC4:</strong> System computes fare estimate before ride and final fare after</li>
    </ul>

    <div class="sub">Non-Functional Requirements</div>
    <ul class="items">
      <li><strong>Availability > Consistency</strong> ‚Äî better to show a slightly stale driver location than to fail a ride request</li>
      <li><strong>Matching latency</strong> ‚Äî &lt;10 seconds from request to driver assignment</li>
      <li><strong>Location freshness</strong> ‚Äî driver location updates every 3‚Äì5 seconds</li>
      <li><strong>Trip state must be durable</strong> ‚Äî can't lose an in-progress trip (strongly consistent)</li>
      <li><strong>Surge pricing can be eventually consistent</strong> ‚Äî a few seconds of staleness is fine</li>
    </ul>

    <div class="callout tip">Notice how I've already made tradeoff decisions: availability > consistency for location, but strong consistency for trip state. This sets up architectural decisions later.</div>

  </div>
</div>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê PHASE 2: ESTIMATION ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<div class="phase" id="p2">
  <div class="phase-header" onclick="this.closest('.phase').classList.toggle('collapsed')">
    <span class="phase-number" style="background:var(--phase2);color:var(--bg)">02</span>
    <span class="phase-title">Back-of-the-Envelope Estimation</span>
    <span class="phase-time">3‚Äì5 min</span>
    <svg class="phase-chevron" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.23 7.21a.75.75 0 011.06.02L10 11.168l3.71-3.938a.75.75 0 111.08 1.04l-4.25 4.5a.75.75 0 01-1.08 0l-4.25-4.5a.75.75 0 01.02-1.06z"/></svg>
  </div>
  <div class="phase-body">

    <div class="callout say">"Let me run quick numbers to identify what drives our architecture."</div>

    <div class="est-grid">
      <div class="est-card">
        <div class="label">Trips / Day</div>
        <div class="value">20M</div>
        <div class="detail">~230 trips/sec average, ~1K/sec peak</div>
      </div>
      <div class="est-card">
        <div class="label">Active Drivers</div>
        <div class="value">~2M concurrent</div>
        <div class="detail">5M total, ~40% online at peak</div>
      </div>
      <div class="est-card">
        <div class="label">Location Updates</div>
        <div class="value">~500K/sec</div>
        <div class="detail">2M drivers √ó 1 update every 4 sec</div>
      </div>
      <div class="est-card">
        <div class="label">Location Storage</div>
        <div class="value">~50 GB/day</div>
        <div class="detail">500K/sec √ó 100 bytes √ó 86,400 sec</div>
      </div>
      <div class="est-card">
        <div class="label">Trip Records</div>
        <div class="value">~20 GB/day</div>
        <div class="detail">20M trips √ó ~1KB each</div>
      </div>
      <div class="est-card">
        <div class="label">WebSocket Connections</div>
        <div class="value">~3M concurrent</div>
        <div class="detail">2M drivers + ~1M active riders at peak</div>
      </div>
    </div>

    <div class="callout decision"><strong>Key insight:</strong> The location update pipeline (500K writes/sec) is the hottest path in the system. This is what drives the architecture ‚Äî it needs a write-optimized, in-memory spatial index, not a traditional database on the write path.</div>

    <div class="callout decision"><strong>Key insight:</strong> 3M concurrent WebSocket connections means we need a horizontally scalable real-time layer. A single server can hold ~50K‚Äì100K connections, so we need 30‚Äì60 connection servers.</div>

  </div>
</div>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê PHASE 3: HIGH-LEVEL DESIGN ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<div class="phase" id="p3">
  <div class="phase-header" onclick="this.closest('.phase').classList.toggle('collapsed')">
    <span class="phase-number" style="background:var(--phase3);color:var(--bg)">03</span>
    <span class="phase-title">High-Level Design</span>
    <span class="phase-time">8‚Äì12 min</span>
    <svg class="phase-chevron" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.23 7.21a.75.75 0 011.06.02L10 11.168l3.71-3.938a.75.75 0 111.08 1.04l-4.25 4.5a.75.75 0 01-1.08 0l-4.25-4.5a.75.75 0 01.02-1.06z"/></svg>
  </div>
  <div class="phase-body">

    <div class="callout say">"Let me sketch the major components and data flows. I'll walk through the ride request flow first, then the driver location tracking flow."</div>

    
    <div class="sub">Key Architecture Decisions</div>
    <div class="callout say">"Here's WHY I chose each technology ‚Äî mapping requirements to tradeoffs. Every choice has a rejected alternative and a consequence."</div>
    <table>
      <thead><tr><th style="width:22%">Requirement</th><th style="width:20%">Decision</th><th style="width:42%">Why (and what was rejected)</th><th style="width:16%">Consistency</th></tr></thead>
      <tbody>
      <tr><td>ACID for trip state (financial record)</td><td style="color:var(--accent-cyan);font-weight:500">PostgreSQL (sharded by city)</td><td>Trips involve payments + state machine transitions that must be atomic. DynamoDB lacks multi-row transactions.</td><td style="color:var(--accent-red);font-weight:600">CP</td></tr>
      <tr><td>125K location writes/sec, append-only</td><td style="color:var(--accent-cyan);font-weight:500">Cassandra (time-series)</td><td>Pure append, never updated. Linear write scaling. PostgreSQL would compete for IOPS with trips.</td><td style="color:var(--accent-green);font-weight:600">AP</td></tr>
      <tr><td>Sub-ms spatial queries for matching</td><td style="color:var(--accent-cyan);font-weight:500">Redis Geospatial</td><td>GEORADIUS in &lt;1ms, TTL auto-expires stale entries. PostGIS is 10-50ms ‚Äî too slow for real-time matching.</td><td style="color:var(--accent-green);font-weight:600">AP</td></tr>
      <tr><td>Decouple billing, analytics, ML from hot path</td><td style="color:var(--accent-cyan);font-weight:500">Kafka event stream</td><td>Durable log with independent consumers. Direct service calls would create tight coupling + no replay.</td><td>‚Äî</td></tr>
      <tr><td>Handle 100K QPS surge without session affinity</td><td style="color:var(--accent-cyan);font-weight:500">Stateless services + API Gateway</td><td>Any pod handles any request. Stateful servers can't scale independently or fail over cleanly.</td><td>‚Äî</td></tr>
      <tr><td>Real-time push to rider/driver apps</td><td style="color:var(--accent-cyan);font-weight:500">WebSocket (not polling)</td><td>Server-initiated push for location + trip state updates. Polling at 4s intervals wastes bandwidth and adds latency.</td><td>‚Äî</td></tr>
      </tbody>
    </table>

    <div class="sub">Major Components (what to draw on Excalidraw)</div>
    <div class="svg-diagram" data-anim>
  <span class="dia-title">High-Level Architecture</span>
  <svg viewBox="0 0 780 656" xmlns="http://www.w3.org/2000/svg" style="font-family:'DM Sans',sans-serif">
    <defs>
      <marker id="topo_8591" markerWidth="7" markerHeight="5" refX="7" refY="2.5" orient="auto"><path d="M0,0 L7,2.5 L0,5" fill="none" stroke="#6e7681" stroke-width="1"/></marker>
      <marker id="topo_8591h" markerWidth="7" markerHeight="5" refX="7" refY="2.5" orient="auto"><path d="M0,0 L7,2.5 L0,5" fill="none" stroke="#39d2c0" stroke-width="1"/></marker>
    </defs>
    <rect x="28" y="28" width="724" height="84" rx="8" fill="rgba(88,166,255,.02)" stroke="rgba(88,166,255,.12)" stroke-dasharray="4 2"/>
    <text x="40" y="41" fill="#58a6ff" font-size="8" font-weight="600" letter-spacing=".1em" opacity=".7">CLIENTS</text>
    <rect x="28" y="128" width="724" height="84" rx="8" fill="rgba(210,153,34,.02)" stroke="rgba(210,153,34,.12)" stroke-dasharray="4 2"/>
    <text x="40" y="141" fill="#d29922" font-size="8" font-weight="600" letter-spacing=".1em" opacity=".7">EDGE / LOAD BALANCING</text>
    <rect x="28" y="228" width="724" height="84" rx="8" fill="rgba(57,210,192,.02)" stroke="rgba(57,210,192,.12)" stroke-dasharray="4 2"/>
    <text x="40" y="241" fill="#39d2c0" font-size="8" font-weight="600" letter-spacing=".1em" opacity=".7">APPLICATION SERVICES</text>
    <rect x="28" y="328" width="724" height="84" rx="8" fill="rgba(227,179,65,.02)" stroke="rgba(227,179,65,.12)" stroke-dasharray="4 2"/>
    <text x="40" y="341" fill="#e3b341" font-size="8" font-weight="600" letter-spacing=".1em" opacity=".7">CACHING</text>
    <rect x="28" y="428" width="724" height="84" rx="8" fill="rgba(188,140,255,.02)" stroke="rgba(188,140,255,.12)" stroke-dasharray="4 2"/>
    <text x="40" y="441" fill="#bc8cff" font-size="8" font-weight="600" letter-spacing=".1em" opacity=".7">MESSAGE QUEUE / ASYNC</text>
    <rect x="28" y="528" width="724" height="84" rx="8" fill="rgba(248,81,73,.02)" stroke="rgba(248,81,73,.12)" stroke-dasharray="4 2"/>
    <text x="40" y="541" fill="#f85149" font-size="8" font-weight="600" letter-spacing=".1em" opacity=".7">DATA STORES</text>
    <line x1="333" y1="94" x2="332" y2="154" stroke="#6e7681" stroke-width="1.2" marker-end="url(#topo_8591)" opacity=".6"/>
    <line x1="447" y1="94" x2="332" y2="154" stroke="#6e7681" stroke-width="1" marker-end="url(#topo_8591)" opacity=".5"/>
    <line x1="447" y1="94" x2="448" y2="154" stroke="#6e7681" stroke-width="1.2" marker-end="url(#topo_8591)" opacity=".6"/>
    <text x="455" y="124" fill="#6e7681" font-size="7" font-family="'JetBrains Mono',monospace" opacity=".7">location</text>
    <line x1="332" y1="194" x2="219" y2="254" stroke="#6e7681" stroke-width="1" marker-end="url(#topo_8591)" opacity=".5"/>
    <line x1="332" y1="194" x2="561" y2="254" stroke="#6e7681" stroke-width="1" marker-end="url(#topo_8591)" opacity=".5"/>
    <line x1="219" y1="254" x2="333" y2="294" stroke="#6e7681" stroke-width="1" marker-end="url(#topo_8591)" opacity=".5"/>
    <line x1="333" y1="254" x2="447" y2="294" stroke="#6e7681" stroke-width="1" marker-end="url(#topo_8591)" opacity=".5"/>
    <line x1="219" y1="294" x2="390" y2="454" stroke="#6e7681" stroke-width="1" marker-end="url(#topo_8591)" opacity=".5"/>
    <line x1="447" y1="294" x2="390" y2="354" stroke="#6e7681" stroke-width="1" marker-end="url(#topo_8591)" opacity=".5"/>
    <line x1="219" y1="294" x2="332" y2="554" stroke="#6e7681" stroke-width="1" marker-end="url(#topo_8591)" opacity=".5"/>
    <line x1="447" y1="294" x2="448" y2="554" stroke="#6e7681" stroke-width="1.2" marker-end="url(#topo_8591)" opacity=".6"/>
    <line x1="390" y1="494" x2="332" y2="554" stroke="#6e7681" stroke-width="1" marker-end="url(#topo_8591)" stroke-dasharray="4 3" opacity=".5"/>
    <line x1="448" y1="154" x2="333" y2="94" stroke="#6e7681" stroke-width="1" marker-end="url(#topo_8591)" stroke-dasharray="4 3" opacity=".5"/>
    <text x="394" y="122" fill="#6e7681" font-size="7" font-family="'JetBrains Mono',monospace" opacity=".7">push</text>
    <rect class="svg-node" x="283" y="54" width="100" height="40" rx="6" fill="rgba(88,166,255,.06)" stroke="rgba(88,166,255,.3)"/>
    <text x="333" y="78" fill="#58a6ff" font-size="10" font-weight="600" text-anchor="middle">üì± Rider App</text>
    <rect class="svg-node" x="397" y="54" width="100" height="40" rx="6" fill="rgba(88,166,255,.06)" stroke="rgba(88,166,255,.3)"/>
    <text x="447" y="78" fill="#58a6ff" font-size="10" font-weight="600" text-anchor="middle">üöó Driver App</text>
    <rect class="svg-node" x="281" y="154" width="102" height="40" rx="6" fill="rgba(210,153,34,.06)" stroke="rgba(210,153,34,.3)"/>
    <text x="332" y="171" fill="#d29922" font-size="10" font-weight="600" text-anchor="middle">üåê API Gateway</text>
    <text x="332" y="184" fill="#6e7681" font-size="8" text-anchor="middle">rate limit ¬∑ auth ¬∑ route</text>
    <rect class="svg-node" x="397" y="154" width="102" height="40" rx="6" fill="rgba(210,153,34,.06)" stroke="rgba(210,153,34,.3)"/>
    <text x="448" y="171" fill="#d29922" font-size="10" font-weight="600" text-anchor="middle">üîå WebSocket</text>
    <text x="448" y="184" fill="#6e7681" font-size="8" text-anchor="middle">real-time push</text>
    <rect class="svg-node" x="169" y="254" width="100" height="40" rx="6" fill="rgba(57,210,192,.06)" stroke="rgba(57,210,192,.3)"/>
    <text x="219" y="271" fill="#39d2c0" font-size="10" font-weight="600" text-anchor="middle">üö¶ Trip Service</text>
    <text x="219" y="284" fill="#6e7681" font-size="8" text-anchor="middle">state machine</text>
    <rect class="svg-node" x="283" y="254" width="100" height="40" rx="6" fill="rgba(57,210,192,.06)" stroke="rgba(57,210,192,.3)"/>
    <text x="333" y="271" fill="#39d2c0" font-size="10" font-weight="600" text-anchor="middle">üîÄ Matching</text>
    <text x="333" y="284" fill="#6e7681" font-size="8" text-anchor="middle">spatial index</text>
    <rect class="svg-node" x="397" y="254" width="100" height="40" rx="6" fill="rgba(57,210,192,.06)" stroke="rgba(57,210,192,.3)"/>
    <text x="447" y="271" fill="#39d2c0" font-size="10" font-weight="600" text-anchor="middle">üìç Location</text>
    <text x="447" y="284" fill="#6e7681" font-size="8" text-anchor="middle">geohash grid</text>
    <rect class="svg-node" x="511" y="254" width="100" height="40" rx="6" fill="rgba(57,210,192,.06)" stroke="rgba(57,210,192,.3)"/>
    <text x="561" y="271" fill="#39d2c0" font-size="10" font-weight="600" text-anchor="middle">üí∞ Pricing</text>
    <text x="561" y="284" fill="#6e7681" font-size="8" text-anchor="middle">surge model</text>
    <rect class="svg-node" x="340" y="354" width="100" height="40" rx="6" fill="rgba(227,179,65,.06)" stroke="rgba(227,179,65,.3)"/>
    <text x="390" y="371" fill="#e3b341" font-size="10" font-weight="600" text-anchor="middle">‚ö° Redis</text>
    <text x="390" y="384" fill="#6e7681" font-size="8" text-anchor="middle">sessions ¬∑ geo ¬∑ surge</text>
    <rect class="svg-node" x="340" y="454" width="100" height="40" rx="6" fill="rgba(188,140,255,.06)" stroke="rgba(188,140,255,.3)"/>
    <text x="390" y="471" fill="#bc8cff" font-size="10" font-weight="600" text-anchor="middle">üì® Kafka</text>
    <text x="390" y="484" fill="#6e7681" font-size="8" text-anchor="middle">trip events ¬∑ location stream</text>
    <rect class="svg-node" x="281" y="554" width="102" height="40" rx="6" fill="rgba(248,81,73,.06)" stroke="rgba(248,81,73,.3)"/>
    <text x="332" y="571" fill="#f85149" font-size="10" font-weight="600" text-anchor="middle">üêò PostgreSQL</text>
    <text x="332" y="584" fill="#6e7681" font-size="8" text-anchor="middle">trips ¬∑ users ¬∑ payments</text>
    <rect class="svg-node" x="397" y="554" width="102" height="40" rx="6" fill="rgba(248,81,73,.06)" stroke="rgba(248,81,73,.3)"/>
    <text x="448" y="571" fill="#f85149" font-size="10" font-weight="600" text-anchor="middle">üìä Cassandra</text>
    <text x="448" y="584" fill="#6e7681" font-size="8" text-anchor="middle">location history</text>
  </svg>
</div>

    <div class="comp-grid">
      <div class="comp-card">
        <h4>üì± Rider App <span class="tag" style="background:rgba(88,166,255,0.15);color:var(--accent-blue)">CLIENT</span></h4>
        <ul>
          <li>Request ride, see ETA, track trip</li>
          <li>WebSocket for real-time updates</li>
        </ul>
      </div>
      <div class="comp-card">
        <h4>üöó Driver App <span class="tag" style="background:rgba(63,185,80,0.15);color:var(--accent-green)">CLIENT</span></h4>
        <ul>
          <li>Send location, accept/reject rides</li>
          <li>WebSocket for dispatch & trip updates</li>
        </ul>
      </div>
      <div class="comp-card">
        <h4>üåê API Gateway <span class="tag" style="background:rgba(210,153,34,0.15);color:var(--accent-orange)">EDGE</span></h4>
        <ul>
          <li>AuthN, rate limiting, routing</li>
          <li>REST for CRUD, WS upgrade for real-time</li>
        </ul>
      </div>
      <div class="comp-card">
        <h4>üîå WebSocket Service <span class="tag" style="background:rgba(188,140,255,0.15);color:var(--accent-purple)">REAL-TIME</span></h4>
        <ul>
          <li>Holds 3M persistent connections</li>
          <li>Horizontally scaled (30‚Äì60 nodes)</li>
          <li>Pushes trip updates & dispatch offers</li>
        </ul>
      </div>
      <div class="comp-card">
        <h4>üìç Location Service <span class="tag" style="background:rgba(248,81,73,0.15);color:var(--accent-red)">HOT PATH</span></h4>
        <ul>
          <li>Ingests 500K loc updates/sec</li>
          <li>In-memory spatial index (geohash grid)</li>
          <li>"Find nearest drivers" queries</li>
        </ul>
      </div>
      <div class="comp-card">
        <h4>üîÄ Matching / Dispatch Service <span class="tag" style="background:rgba(57,210,192,0.15);color:var(--accent-cyan)">CORE</span></h4>
        <ul>
          <li>Queries Location Service for nearby drivers</li>
          <li>Ranks by ETA, rating, vehicle type</li>
          <li>Sends offer to best driver via WS</li>
        </ul>
      </div>
      <div class="comp-card">
        <h4>üö¶ Trip Service <span class="tag" style="background:rgba(227,179,65,0.15);color:var(--accent-yellow)">CORE</span></h4>
        <ul>
          <li>Trip state machine (requested ‚Üí matched ‚Üí pickup ‚Üí in_ride ‚Üí completed)</li>
          <li>Strongly consistent (PostgreSQL)</li>
        </ul>
      </div>
      <div class="comp-card">
        <h4>üí∞ Pricing Service <span class="tag" style="background:rgba(210,153,34,0.15);color:var(--accent-orange)">CORE</span></h4>
        <ul>
          <li>Fare estimate before ride</li>
          <li>Surge multiplier computation</li>
          <li>Final fare calculation after ride</li>
        </ul>
      </div>
    </div>

    <div class="sub">Flow 1: Rider Requests a Ride</div>
<div class="svg-diagram" data-anim>
  <span class="dia-title">Questions I'd Ask</span>
  <svg viewBox="0 0 560 736" xmlns="http://www.w3.org/2000/svg" style="font-family:'DM Sans',sans-serif">
    <defs><marker id="a1009" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto"><path d="M0,0 L8,3 L0,6" fill="none" stroke="#6e7681" stroke-width="1.2"/></marker></defs>
    <rect class="svg-node" x="127" y="40" width="307" height="44" rx="7" fill="rgba(248,81,73,.06)" stroke="rgba(248,81,73,.3)"/>
    <text x="280" y="68" fill="#f85149" font-size="12" font-weight="600" text-anchor="middle">Rider App</text>
    <line x1="280" y1="84" x2="280" y2="122" stroke="#6e7681" stroke-width="1.3" marker-end="url(#a1009)"/>
    <rect class="svg-node" x="124" y="124" width="313" height="44" rx="7" fill="rgba(57,210,192,.06)" stroke="rgba(57,210,192,.3)"/>
    <text x="280" y="152" fill="#39d2c0" font-size="12" font-weight="600" text-anchor="middle">API Gateway</text>
    <line x1="280" y1="168" x2="280" y2="222" stroke="#6e7681" stroke-width="1.3" marker-end="url(#a1009)"/>
    <text x="296" y="184" fill="#d29922" font-size="9" font-family="'JetBrains Mono',monospace">creates trip (status: REQUESTED)</text>
    <rect class="svg-node" x="122" y="224" width="316" height="44" rx="7" fill="rgba(88,166,255,.06)" stroke="rgba(88,166,255,.3)"/>
    <text x="280" y="252" fill="#58a6ff" font-size="12" font-weight="600" text-anchor="middle">Trip Service</text>
    <line x1="280" y1="268" x2="280" y2="306" stroke="#6e7681" stroke-width="1.3" marker-end="url(#a1009)"/>
    <rect class="svg-node" x="116" y="308" width="328" height="44" rx="7" fill="rgba(210,153,34,.06)" stroke="rgba(210,153,34,.3)"/>
    <text x="280" y="336" fill="#d29922" font-size="12" font-weight="600" text-anchor="middle">Matching Service</text>
    <line x1="280" y1="352" x2="280" y2="438" stroke="#6e7681" stroke-width="1.3" marker-end="url(#a1009)"/>
    <text x="296" y="368" fill="#d29922" font-size="9" font-family="'JetBrains Mono',monospace">"find 5 nearest available (spatial index lookup)</text>
    <text x="296" y="384" fill="#d29922" font-size="9" font-family="'JetBrains Mono',monospace">drivers within 5km"</text>
    <text x="296" y="400" fill="#d29922" font-size="9" font-family="'JetBrains Mono',monospace">rank by ETA, pick best</text>
    <rect class="svg-node" x="116" y="440" width="328" height="44" rx="7" fill="rgba(63,185,80,.06)" stroke="rgba(63,185,80,.3)"/>
    <text x="280" y="468" fill="#3fb950" font-size="12" font-weight="600" text-anchor="middle">Location Service</text>
    <line x1="280" y1="484" x2="280" y2="522" stroke="#6e7681" stroke-width="1.3" marker-end="url(#a1009)"/>
    <rect class="svg-node" x="115" y="524" width="331" height="44" rx="7" fill="rgba(188,140,255,.06)" stroke="rgba(188,140,255,.3)"/>
    <text x="280" y="552" fill="#bc8cff" font-size="12" font-weight="600" text-anchor="middle">WebSocket Service</text>
    <line x1="280" y1="568" x2="280" y2="670" stroke="#6e7681" stroke-width="1.3" marker-end="url(#a1009)"/>
    <text x="296" y="584" fill="#d29922" font-size="9" font-family="'JetBrains Mono',monospace">"ride offer: pickup at X, (accept / reject)</text>
    <text x="296" y="600" fill="#d29922" font-size="9" font-family="'JetBrains Mono',monospace">rider is 3 min away"</text>
    <text x="296" y="616" fill="#d29922" font-size="9" font-family="'JetBrains Mono',monospace">on accept ‚Üí update Trip (status: MATCHED)</text>
    <text x="296" y="632" fill="#d29922" font-size="9" font-family="'JetBrains Mono',monospace">on reject ‚Üí offer to next driver</text>
    <rect class="svg-node" x="125" y="672" width="310" height="44" rx="7" fill="rgba(227,179,65,.06)" stroke="rgba(227,179,65,.3)"/>
    <text x="280" y="700" fill="#e3b341" font-size="12" font-weight="600" text-anchor="middle">Driver App</text>
  </svg>
</div>

    <div class="sub">Flow 2: Driver Location Tracking</div>
<div class="svg-diagram" data-anim>
  <span class="dia-title">Flow 2: Driver Location Tracking</span>
  <svg viewBox="0 0 560 404" xmlns="http://www.w3.org/2000/svg" style="font-family:'DM Sans',sans-serif">
    <defs><marker id="a4913" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto"><path d="M0,0 L8,3 L0,6" fill="none" stroke="#6e7681" stroke-width="1.2"/></marker></defs>
    <rect class="svg-node" x="125" y="40" width="310" height="44" rx="7" fill="rgba(248,81,73,.06)" stroke="rgba(248,81,73,.3)"/>
    <text x="280" y="68" fill="#f85149" font-size="12" font-weight="600" text-anchor="middle">Driver App</text>
    <line x1="280" y1="84" x2="280" y2="122" stroke="#6e7681" stroke-width="1.3" marker-end="url(#a4913)"/>
    <rect class="svg-node" x="115" y="124" width="331" height="44" rx="7" fill="rgba(57,210,192,.06)" stroke="rgba(57,210,192,.3)"/>
    <text x="280" y="152" fill="#39d2c0" font-size="12" font-weight="600" text-anchor="middle">WebSocket Service</text>
    <line x1="280" y1="168" x2="280" y2="238" stroke="#6e7681" stroke-width="1.3" marker-end="url(#a4913)"/>
    <text x="296" y="184" fill="#d29922" font-size="9" font-family="'JetBrains Mono',monospace">update in-memory spatial index</text>
    <text x="296" y="200" fill="#d29922" font-size="9" font-family="'JetBrains Mono',monospace">async write to Kafka for persistence</text>
    <rect class="svg-node" x="116" y="240" width="328" height="44" rx="7" fill="rgba(88,166,255,.06)" stroke="rgba(88,166,255,.3)"/>
    <text x="280" y="268" fill="#58a6ff" font-size="12" font-weight="600" text-anchor="middle">Location Service</text>
    <line x1="280" y1="284" x2="280" y2="338" stroke="#6e7681" stroke-width="1.3" marker-end="url(#a4913)"/>
    <text x="296" y="300" fill="#d29922" font-size="9" font-family="'JetBrains Mono',monospace">(append-only, for analytics &amp; ETA models)</text>
    <rect class="svg-node" x="112" y="340" width="337" height="44" rx="7" fill="rgba(210,153,34,.06)" stroke="rgba(210,153,34,.3)"/>
    <text x="280" y="368" fill="#d29922" font-size="12" font-weight="600" text-anchor="middle">Location History DB</text>
  </svg>
</div>

    <div class="sub">Flow 3: Live Trip Tracking</div>
<div class="svg-diagram" data-anim>
  <span class="dia-title">Flow 3: Live Trip Tracking</span>
  <svg viewBox="0 0 560 388" xmlns="http://www.w3.org/2000/svg" style="font-family:'DM Sans',sans-serif">
    <defs><marker id="a9430" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto"><path d="M0,0 L8,3 L0,6" fill="none" stroke="#6e7681" stroke-width="1.2"/></marker></defs>
    <rect class="svg-node" x="125" y="40" width="310" height="44" rx="7" fill="rgba(248,81,73,.06)" stroke="rgba(248,81,73,.3)"/>
    <text x="280" y="68" fill="#f85149" font-size="12" font-weight="600" text-anchor="middle">Driver App</text>
    <line x1="280" y1="84" x2="280" y2="122" stroke="#6e7681" stroke-width="1.3" marker-end="url(#a9430)"/>
    <rect class="svg-node" x="116" y="124" width="328" height="44" rx="7" fill="rgba(57,210,192,.06)" stroke="rgba(57,210,192,.3)"/>
    <text x="280" y="152" fill="#39d2c0" font-size="12" font-weight="600" text-anchor="middle">Location Service</text>
    <line x1="280" y1="168" x2="280" y2="222" stroke="#6e7681" stroke-width="1.3" marker-end="url(#a9430)"/>
    <text x="296" y="184" fill="#d29922" font-size="9" font-family="'JetBrains Mono',monospace">push update via WS</text>
    <rect class="svg-node" x="122" y="224" width="316" height="44" rx="7" fill="rgba(88,166,255,.06)" stroke="rgba(88,166,255,.3)"/>
    <text x="280" y="252" fill="#58a6ff" font-size="12" font-weight="600" text-anchor="middle">Trip Service</text>
    <line x1="280" y1="268" x2="280" y2="322" stroke="#6e7681" stroke-width="1.3" marker-end="url(#a9430)"/>
    <text x="296" y="284" fill="#d29922" font-size="9" font-family="'JetBrains Mono',monospace">(sees driver moving on map)</text>
    <rect class="svg-node" x="127" y="324" width="307" height="44" rx="7" fill="rgba(210,153,34,.06)" stroke="rgba(210,153,34,.3)"/>
    <text x="280" y="352" fill="#d29922" font-size="12" font-weight="600" text-anchor="middle">Rider App</text>
  </svg>
</div>

    <div class="callout say">"That covers the three main flows. The hottest path is the location ingestion pipeline ‚Äî 500K writes/sec. The most critical path is the trip state machine ‚Äî we can't lose trip state. I'd like to deep-dive into the Location Service first since it's the most architecturally interesting. Sound good?"</div>

  </div>
</div>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê PHASE 4: DEEP DIVES ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<div class="phase" id="p4">
  <div class="phase-header" onclick="this.closest('.phase').classList.toggle('collapsed')">
    <span class="phase-number" style="background:var(--phase4)">04</span>
    <span class="phase-title">Deep Dives</span>
    <span class="phase-time">25‚Äì30 min</span>
    <svg class="phase-chevron" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.23 7.21a.75.75 0 011.06.02L10 11.168l3.71-3.938a.75.75 0 111.08 1.04l-4.25 4.5a.75.75 0 01-1.08 0l-4.25-4.5a.75.75 0 01.02-1.06z"/></svg>
  </div>
  <div class="phase-body">

    <!-- ‚îÄ‚îÄ DD1: Location & Matching ‚îÄ‚îÄ -->
    <div id="dd-location">
    <div class="sub">Deep Dive 1: Location Service & Driver Matching (~10 min)</div>

    <div class="callout goal"><strong>The core challenge:</strong> Index 2M driver locations, handle 500K updates/sec, and answer "find nearest available drivers" queries in &lt;50ms.</div>

    <p style="color:var(--text-muted);margin:12px 0;font-size:13.5px;line-height:1.6;"><strong style="color:var(--text)">Spatial Indexing Strategy ‚Äî Geohash Grid</strong><br>
    Divide the world into geohash cells (precision 6 = ~1.2km √ó 0.6km). Each cell maps to a set of driver IDs. When a rider requests a ride, compute their geohash and query that cell plus neighboring cells.</p>

    <div class="callout decision"><strong>Why geohash over R-tree or quadtree?</strong> Geohashes are strings, so they're trivially partitioned across a distributed in-memory store (Redis or custom). R-trees give better query precision but are harder to distribute. At our scale, the simplicity of geohash-based sharding wins. The tradeoff is edge-case inaccuracy at cell boundaries ‚Äî mitigated by always querying neighboring cells.</div>

    <p style="color:var(--text-muted);margin:12px 0;font-size:13.5px;line-height:1.6;"><strong style="color:var(--text)">In-Memory Architecture</strong></p>
    <table>
      <thead><tr><th>Component</th><th>Tech</th><th>Rationale</th></tr></thead>
      <tbody>
        <tr><td>Spatial Index</td><td>Redis Cluster (sorted sets per geohash)</td><td>In-memory, O(log N) updates, 500K writes/sec is feasible across a cluster</td></tr>
        <tr><td>Driver State</td><td>Redis hash per driver</td><td>Status (available/busy/offline), current geohash, vehicle type</td></tr>
        <tr><td>Persistence</td><td>Kafka ‚Üí Cassandra</td><td>Location history for ETA models and analytics. Async ‚Äî not on hot path</td></tr>
      </tbody>
    </table>

    <div class="schema"><span class="comment">‚îÄ‚îÄ Redis: Spatial Index ‚îÄ‚îÄ</span>
<span class="table-name">SORTED SET</span>  key: <span class="pk">geohash:{cell_id}</span>
              member: driver_id
              score: timestamp (for TTL-based eviction of stale drivers)

<span class="comment">‚îÄ‚îÄ Redis: Driver State ‚îÄ‚îÄ</span>
<span class="table-name">HASH</span>  key: <span class="pk">driver:{driver_id}</span>
       status: <span class="type">available | on_trip | offline</span>
       geohash: <span class="type">string</span>
       lat/lng: <span class="type">float</span>
       vehicle_type: <span class="type">economy | premium | xl</span>
       last_updated: <span class="type">timestamp</span></div>

    <p style="color:var(--text-muted);margin:12px 0;font-size:13.5px;line-height:1.6;"><strong style="color:var(--text)">Matching Algorithm</strong></p>
    <ul class="items">
      <li><strong>Step 1:</strong> Compute rider's geohash ‚Üí query that cell + 8 neighbors ‚Üí get candidate driver IDs</li>
      <li><strong>Step 2:</strong> Filter by status=available, vehicle_type match</li>
      <li><strong>Step 3:</strong> Compute ETA for top candidates (call Maps/routing service)</li>
      <li><strong>Step 4:</strong> Rank by ETA (primary), driver rating (secondary)</li>
      <li><strong>Step 5:</strong> Send ride offer to top-ranked driver via WebSocket</li>
      <li><strong>Step 6:</strong> If rejected or timeout (10s) ‚Üí offer to next driver. Max 3 attempts before expanding search radius.</li>
    </ul>

    <div class="callout decision"><strong>Why not broadcast to all nearby drivers?</strong> Broadcasting creates a thundering herd ‚Äî multiple drivers accept the same ride, then we cancel all but one, causing bad driver experience. Serial dispatch with timeout is simpler and more predictable. Tradeoff: slightly higher matching latency (potentially 10‚Äì30s if first drivers reject), but much better UX for drivers.</div>

    <div class="callout tip">Hot spot mitigation: In dense areas (airports, stadiums) a single geohash cell could have thousands of drivers. We can use finer-grained geohashes (precision 7 or 8) in high-density areas, or use a two-level index: coarse for initial lookup, fine for ranking.</div>
    </div>

    <!-- ‚îÄ‚îÄ DD2: Trip Lifecycle ‚îÄ‚îÄ -->
    <div id="dd-trip">
    <div class="sub">Deep Dive 2: Trip Service & State Machine (~8 min)</div>

    <div class="callout goal"><strong>The core challenge:</strong> Trip state must never be lost. Transitions must be atomic. Both rider and driver must see the same state.</div>

    <p style="color:var(--text-muted);margin:12px 0;font-size:13.5px;line-height:1.6;"><strong style="color:var(--text)">State Machine</strong></p>
<div class="svg-diagram" data-anim>
  <span class="dia-title">State Machine</span>
  <svg viewBox="0 0 760 102" xmlns="http://www.w3.org/2000/svg" style="font-family:'DM Sans',sans-serif">
    <defs><marker id="sm9664" markerWidth="7" markerHeight="5" refX="7" refY="2.5" orient="auto"><path d="M0,0 L7,2.5 L0,5" fill="none" stroke="#6e7681" stroke-width="1"/></marker></defs>
    <rect class="svg-node" x="15" y="30" width="100" height="32" rx="5" fill="rgba(248,81,73,.07)" stroke="rgba(248,81,73,.3)"/>
    <text x="65" y="50" fill="#f85149" font-size="9" font-weight="600" text-anchor="middle" font-family="'JetBrains Mono',monospace">REQUESTED</text>
    <line x1="115" y1="46" x2="120.0" y2="46" stroke="#6e7681" stroke-width="1.2" marker-end="url(#sm9664)"/>
    <rect class="svg-node" x="120.0" y="30" width="100" height="32" rx="5" fill="rgba(57,210,192,.07)" stroke="rgba(57,210,192,.3)"/>
    <text x="170.0" y="50" fill="#39d2c0" font-size="9" font-weight="600" text-anchor="middle" font-family="'JetBrains Mono',monospace">MATCHED</text>
    <line x1="220.0" y1="46" x2="260.0" y2="46" stroke="#6e7681" stroke-width="1.2" marker-end="url(#sm9664)"/>
    <rect class="svg-node" x="260.0" y="30" width="100" height="32" rx="5" fill="rgba(88,166,255,.07)" stroke="rgba(88,166,255,.3)"/>
    <text x="310.0" y="50" fill="#58a6ff" font-size="9" font-weight="600" text-anchor="middle" font-family="'JetBrains Mono',monospace">DRIVER_ARRIVED</text>
    <line x1="360.0" y1="46" x2="400.0" y2="46" stroke="#6e7681" stroke-width="1.2" marker-end="url(#sm9664)"/>
    <rect class="svg-node" x="400.0" y="30" width="100" height="32" rx="5" fill="rgba(210,153,34,.07)" stroke="rgba(210,153,34,.3)"/>
    <text x="450.0" y="50" fill="#d29922" font-size="9" font-weight="600" text-anchor="middle" font-family="'JetBrains Mono',monospace">NO_DRIVERS</text>
    <line x1="500.0" y1="46" x2="540.0" y2="46" stroke="#6e7681" stroke-width="1.2" marker-end="url(#sm9664)"/>
    <rect class="svg-node" x="540.0" y="30" width="100" height="32" rx="5" fill="rgba(63,185,80,.07)" stroke="rgba(63,185,80,.3)"/>
    <text x="590.0" y="50" fill="#3fb950" font-size="9" font-weight="600" text-anchor="middle" font-family="'JetBrains Mono',monospace">IN_PROGRESS</text>
    <line x1="640.0" y1="46" x2="645" y2="46" stroke="#6e7681" stroke-width="1.2" marker-end="url(#sm9664)"/>
    <rect class="svg-node" x="645" y="30" width="100" height="32" rx="5" fill="rgba(188,140,255,.07)" stroke="rgba(188,140,255,.3)"/>
    <text x="695" y="50" fill="#bc8cff" font-size="9" font-weight="600" text-anchor="middle" font-family="'JetBrains Mono',monospace">COMPLETED</text>
  </svg>
</div>

    <div class="callout decision"><strong>Storage: PostgreSQL</strong> ‚Äî Trip state is our most critical data. It involves multi-field updates (status, driver_id, fare, timestamps) and we need ACID transactions. The write volume (~230 trips/sec average, ~1K peak) is well within Postgres capacity. We'd shard by city or region if we outgrow a single instance. Tradeoff vs. DynamoDB: we lose auto-scaling but gain transactional guarantees and query flexibility for operational dashboards.</div>

    <div class="schema"><span class="table-name">trips</span>
  <span class="pk">id</span>              <span class="type">UUID PK</span>
  <span class="fk">rider_id</span>        <span class="type">UUID FK ‚Üí users</span>
  <span class="fk">driver_id</span>       <span class="type">UUID FK ‚Üí users (nullable until matched)</span>
  status          <span class="type">ENUM (requested, matched, arrived, in_progress, completed, cancelled)</span>
  pickup_lat/lng  <span class="type">FLOAT</span>
  dropoff_lat/lng <span class="type">FLOAT</span>
  fare_estimate   <span class="type">DECIMAL</span>
  fare_final      <span class="type">DECIMAL (null until completed)</span>
  surge_mult      <span class="type">DECIMAL</span>
  requested_at    <span class="type">TIMESTAMP</span>
  matched_at      <span class="type">TIMESTAMP</span>
  started_at      <span class="type">TIMESTAMP</span>
  completed_at    <span class="type">TIMESTAMP</span>
  city_id         <span class="type">INT (partition key for sharding)</span>

<span class="comment">-- Indexes: (rider_id, status), (driver_id, status), (city_id, requested_at)</span></div>

    <p style="color:var(--text-muted);margin:12px 0;font-size:13.5px;line-height:1.6;"><strong style="color:var(--text)">Event Publishing</strong><br>
    On every state transition, Trip Service publishes an event to Kafka: <code style="font-family:var(--font-mono);font-size:12px;background:var(--surface-raised);padding:1px 5px;border-radius:3px;">trip.status_changed {trip_id, old_status, new_status, timestamp}</code>. Consumers include: WebSocket Service (push to rider/driver apps), Pricing Service (trigger fare calculation on COMPLETED), Analytics pipeline.</p>

    <div class="callout decision"><strong>Why event-driven for updates instead of polling?</strong> With 20M trips/day, polling from multiple consumers would create massive DB load. Publishing events on state transitions decouples consumers, allows fan-out, and keeps the Trip DB write-path clean. Tradeoff: we accept eventual consistency for the push updates (ms-level delay), but the source of truth (Postgres) is always strongly consistent.</div>
    </div>

    <!-- ‚îÄ‚îÄ DD3: Pricing & Surge ‚îÄ‚îÄ -->
    <div id="dd-pricing">
    <div class="sub">Deep Dive 3: Pricing & Surge (~7 min)</div>

    <div class="callout goal"><strong>The core challenge:</strong> Compute accurate fare estimates in &lt;100ms. Dynamically adjust prices (surge) based on supply/demand without being stale or oscillating wildly.</div>

    <p style="color:var(--text-muted);margin:12px 0;font-size:13.5px;line-height:1.6;"><strong style="color:var(--text)">Fare Calculation</strong></p>
    <div class="schema"><span class="comment">‚îÄ‚îÄ Fare Formula ‚îÄ‚îÄ</span>
fare = base_fare
     + (per_mile_rate √ó distance)
     + (per_minute_rate √ó duration)
     + booking_fee
     √ó <span class="pk">surge_multiplier</span>

<span class="comment">‚îÄ‚îÄ Where ‚îÄ‚îÄ</span>
distance, duration = from routing/maps service (precomputed ETA)
surge_multiplier   = from Surge Service (per geohash cell)</div>

    <p style="color:var(--text-muted);margin:12px 0;font-size:13.5px;line-height:1.6;"><strong style="color:var(--text)">Surge Pricing Design</strong></p>
    <ul class="items">
      <li><strong>Input signals:</strong> Demand (ride requests per cell per minute) and supply (available drivers per cell)</li>
      <li><strong>Computation:</strong> A background job runs every 30‚Äì60 seconds per city. For each geohash cell, compute demand/supply ratio ‚Üí map to surge multiplier via a configurable curve.</li>
      <li><strong>Storage:</strong> Redis hash ‚Äî <code>surge:{city}:{geohash} ‚Üí multiplier</code>. TTL of 2 minutes (auto-expire if job fails).</li>
      <li><strong>Smoothing:</strong> Apply exponential moving average to prevent wild oscillation. Multiplier changes are capped at ¬±0.5x per cycle.</li>
    </ul>

    <div class="callout decision"><strong>Why precomputed + cached, not real-time per-request?</strong> Computing supply/demand per request would require querying the Location Service for every fare estimate ‚Äî that's 1K QPS hitting the spatial index just for pricing. Precomputing every 30‚Äì60s and caching in Redis keeps the pricing path fast (&lt;5ms lookup) and decouples it from the location hot path. Tradeoff: surge can be up to 60s stale, which is acceptable ‚Äî riders see the multiplier before confirming.</div>

    <div class="callout tip"><strong>Fairness guard:</strong> The fare shown at request time is what the rider pays. If surge drops during the ride, they pay the lower of estimate and actual. This is a product decision but it has architectural implications ‚Äî we need to store the surge_multiplier at request time on the trip record.</div>
    </div>

    <!-- ‚îÄ‚îÄ DD4: Data Model Overview ‚îÄ‚îÄ -->
    <div id="dd-data">
    <div class="sub">Deep Dive 4: Data Model & Storage Summary (~5 min)</div>

    <table>
      <thead><tr><th>Data</th><th>Store</th><th>Access Pattern</th><th>Consistency</th></tr></thead>
      <tbody>
        <tr><td>Driver Location (live)</td><td>Redis Cluster</td><td>500K writes/sec, spatial queries</td><td>Eventual (best-effort)</td></tr>
        <tr><td>Driver Location (history)</td><td>Cassandra</td><td>Append-only, time-range queries for ETA/analytics</td><td>Eventual</td></tr>
        <tr><td>Trip State</td><td>PostgreSQL</td><td>CRUD by trip_id, query by rider/driver + status</td><td>Strong (ACID)</td></tr>
        <tr><td>User Profiles</td><td>PostgreSQL</td><td>Read by user_id, low write frequency</td><td>Strong</td></tr>
        <tr><td>Surge Multipliers</td><td>Redis</td><td>Read by geohash, written every 30‚Äì60s</td><td>Eventual (TTL 2m)</td></tr>
        <tr><td>Event Stream</td><td>Kafka</td><td>Pub/sub for trip events, location events</td><td>Ordered per partition</td></tr>
      </tbody>
    </table>

    <div class="callout decision"><strong>Why not one database for everything?</strong> Because the access patterns are radically different. Location needs in-memory spatial indexing at 500K/sec ‚Äî no traditional DB handles that. Trips need ACID ‚Äî Redis doesn't provide that. History is append-only at massive volume ‚Äî Cassandra's sweet spot. Each store is matched to its access pattern.</div>
    </div>

  </div>
</div>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê API DESIGN ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<div class="phase" id="apis">
  <div class="phase-header" onclick="this.closest('.phase').classList.toggle('collapsed')">
    <span class="phase-number" style="background:var(--accent-cyan);color:var(--bg)">üì°</span>
    <span class="phase-title">API Design</span>
    <svg class="phase-chevron" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.23 7.21a.75.75 0 011.06.02L10 11.168l3.71-3.938a.75.75 0 111.08 1.04l-4.25 4.5a.75.75 0 01-1.08 0l-4.25-4.5a.75.75 0 01.02-1.06z"/></svg>
  </div>
  <div class="phase-body">
    <div class="sub">REST Endpoints</div>
    <div class="api-block">
      <div class="api-method"><span class="verb post">POST</span><span class="path">/v1/rides/estimate</span><span class="desc">Get fare estimate + ETA before requesting</span></div>
      <div class="api-body">Request: <code>{pickup: {lat, lng}, dropoff: {lat, lng}, vehicle_type}</code><br>Response: <code>{fare_estimate, surge_multiplier, eta_minutes, ride_token}</code></div>
    </div>
    <div class="api-block">
      <div class="api-method"><span class="verb post">POST</span><span class="path">/v1/rides</span><span class="desc">Request a ride (rider)</span></div>
      <div class="api-body">Request: <code>{ride_token, pickup, dropoff, vehicle_type, payment_method_id}</code><br>Response: <code>{trip_id, status: "REQUESTED"}</code> ‚Äî subsequent updates come via WebSocket</div>
    </div>
    <div class="api-block">
      <div class="api-method"><span class="verb put">PUT</span><span class="path">/v1/rides/{trip_id}/accept</span><span class="desc">Driver accepts ride offer</span></div>
      <div class="api-body">Response: <code>{trip_id, rider_info, pickup, dropoff}</code></div>
    </div>
    <div class="api-block">
      <div class="api-method"><span class="verb put">PUT</span><span class="path">/v1/rides/{trip_id}/status</span><span class="desc">Transition trip state</span></div>
      <div class="api-body">Request: <code>{status: "ARRIVED" | "IN_PROGRESS" | "COMPLETED" | "CANCELLED"}</code></div>
    </div>
    <div class="api-block">
      <div class="api-method"><span class="verb get">GET</span><span class="path">/v1/rides/{trip_id}</span><span class="desc">Get trip details</span></div>
    </div>

    <div class="sub">WebSocket Channels</div>
    <div class="api-block">
      <div class="api-method"><span class="verb ws">WS</span><span class="path">/v1/ws/driver</span><span class="desc">Driver: send location, receive dispatch offers</span></div>
      <div class="api-body">
        Inbound: <code>{type: "location", lat, lng, timestamp}</code> (every 4s)<br>
        Outbound: <code>{type: "ride_offer", trip_id, pickup, rider_name, fare_estimate}</code><br>
        Outbound: <code>{type: "trip_update", trip_id, status, ...}</code>
      </div>
    </div>
    <div class="api-block">
      <div class="api-method"><span class="verb ws">WS</span><span class="path">/v1/ws/rider</span><span class="desc">Rider: receive trip updates & driver location</span></div>
      <div class="api-body">
        Outbound: <code>{type: "trip_update", trip_id, status, driver_location, eta}</code><br>
        Outbound: <code>{type: "driver_location", lat, lng}</code> (every 4s during active trip)
      </div>
    </div>
  </div>
</div>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê PHASE 5: CROSS-CUTTING ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<div class="phase" id="p5">
  <div class="phase-header" onclick="this.closest('.phase').classList.toggle('collapsed')">
    <span class="phase-number" style="background:var(--phase5)">05</span>
    <span class="phase-title">Cross-Cutting Concerns</span>
    <span class="phase-time">10‚Äì12 min</span>
    <svg class="phase-chevron" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.23 7.21a.75.75 0 011.06.02L10 11.168l3.71-3.938a.75.75 0 111.08 1.04l-4.25 4.5a.75.75 0 01-1.08 0l-4.25-4.5a.75.75 0 01.02-1.06z"/></svg>
  </div>
  <div class="phase-body">
    <div class="sub">Storage Architecture Summary</div>
    <div class="callout goal"><strong>What goes where and why.</strong> Each data store is chosen for its access pattern ‚Äî not by default. The question isn't "which database?" but "what are the read/write patterns, consistency requirements, and scale characteristics?"</div>
    <table>
      <thead><tr><th>Data</th><th>Store</th><th>Why This Store</th></tr></thead>
      <tbody>
      <tr>
        <td>Trip state &amp; history</td>
        <td style="color:var(--accent-cyan)">PostgreSQL</td>
        <td>ACID for state machine transitions. Sharded by city_id. Trips are financial records ‚Äî strong consistency required.</td>
      </tr>
      <tr>
        <td>Driver locations (live)</td>
        <td style="color:var(--accent-cyan)">Redis (Geospatial)</td>
        <td>GEOADD/GEORADIUS for spatial queries. TTL=30s auto-expires stale locations. ~500K active drivers in memory.</td>
      </tr>
      <tr>
        <td>Location history</td>
        <td style="color:var(--accent-cyan)">Cassandra</td>
        <td>Append-only time-series writes. Partitioned by driver_id + date. High write throughput, no updates needed.</td>
      </tr>
      <tr>
        <td>Surge pricing zones</td>
        <td style="color:var(--accent-cyan)">Redis</td>
        <td>Precomputed per geohash cell. Updated every 30s by pricing service. Read-heavy, low latency required.</td>
      </tr>
      <tr>
        <td>User profiles &amp; payments</td>
        <td style="color:var(--accent-cyan)">PostgreSQL</td>
        <td>Relational data with foreign keys. PCI-compliant vault for payment tokens. Read-heavy, strong consistency.</td>
      </tr>
      <tr>
        <td>Trip events stream</td>
        <td style="color:var(--accent-cyan)">Kafka</td>
        <td>Durable event log. trip.requested, trip.matched, trip.completed. Consumed by analytics, billing, ETA models.</td>
      </tr>
      </tbody>
    </table>


    <div class="sub" id="failures">Failure Scenarios & Mitigation</div>
    <div class="failure-row"><span class="scenario">Location Service node dies</span><span class="mitigation">Redis Cluster auto-failover to replica. Drivers re-register location on reconnect. A few seconds of stale data ‚Äî acceptable per our consistency model.</span></div>
    <div class="failure-row"><span class="scenario">WebSocket server crashes</span><span class="mitigation">Clients reconnect to a different node (sticky sessions via driver/rider ID). Trip state is in Postgres, so no data lost ‚Äî just a brief reconnection delay.</span></div>
    <div class="failure-row"><span class="scenario">Driver accepts but goes offline</span><span class="mitigation">Trip Service has a heartbeat timeout. If no location update from driver for 30s after MATCHED, auto-reassign to next driver. Rider gets notified.</span></div>
    <div class="failure-row"><span class="scenario">Matching Service can't find drivers</span><span class="mitigation">Expand search radius in concentric rings (5km ‚Üí 10km ‚Üí 15km). After 3 expansions, return NO_DRIVERS status. Trigger surge pricing increase for that area.</span></div>
    <div class="failure-row"><span class="scenario">Kafka consumer lag</span><span class="mitigation">Location history writes fall behind but the real-time spatial index (Redis) is unaffected. Trip events: if WebSocket push is delayed, rider/driver can poll GET /rides/{id} as fallback.</span></div>
    <div class="failure-row"><span class="scenario">PostgreSQL (Trip DB) down</span><span class="mitigation">This is our most critical failure. Primary-replica setup with automatic failover. If both are down, no new trips can be created ‚Äî we show "service temporarily unavailable." In-progress trips continue (driver has cached trip info) but state transitions queue until recovery.</span></div>

    <div class="sub">Scalability Bottlenecks</div>
    <table>
      <thead><tr><th>At Scale</th><th>What Breaks</th><th>Mitigation</th></tr></thead>
      <tbody>
        <tr><td>10√ó (200M trips/day)</td><td>Single-city Postgres shard gets hot. Redis spatial index memory pressure.</td><td>Shard Trip DB by city_id. Partition Redis by geo-region.</td></tr>
        <tr><td>100√ó (2B trips/day)</td><td>Matching Service becomes bottleneck ‚Äî ETA computation is expensive. WebSocket tier needs 300-600 nodes.</td><td>Pre-compute ETAs in a spatial grid. Move to gRPC between internal services. Regional deployments.</td></tr>
      </tbody>
    </table>

    <div class="sub">Observability</div>
    <ul class="items">
      <li><strong>Golden signals per service:</strong> Request rate, error rate (4xx/5xx), p50/p99 latency, saturation (CPU, memory, connections)</li>
      <li><strong>Business metrics:</strong> Match rate (% of requests that get a driver), time-to-match, surge coverage, cancellation rate</li>
      <li><strong>Distributed tracing:</strong> Trace from ride request ‚Üí matching ‚Üí dispatch ‚Üí acceptance. Critical for debugging "why did matching take 30 seconds?"</li>
      <li><strong>Alerting:</strong> Match rate drops below 80%, time-to-match p99 > 30s, Trip DB replication lag > 5s, WebSocket reconnection spike</li>
    </ul>

    <div class="sub">Security Highlights</div>
    <ul class="items">
      <li><strong>AuthN:</strong> JWT tokens per session, short-lived (15 min) with refresh tokens. Separate tokens for rider and driver roles.</li>
      <li><strong>Location privacy:</strong> Rider's exact location is only shared with matched driver. Never expose driver home address.</li>
      <li><strong>Rate limiting:</strong> Ride requests capped per user (prevent abuse). Location updates capped per driver (prevent spoofing).</li>
      <li><strong>Fare tampering:</strong> Surge multiplier is server-side only. <code>ride_token</code> is signed ‚Äî client can't modify fare estimate.</li>
    </ul>

  </div>
</div>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê PHASE 6: WRAP-UP ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<div class="phase" id="p6">
  <div class="phase-header" onclick="this.closest('.phase').classList.toggle('collapsed')">
    <span class="phase-number" style="background:var(--phase6);color:var(--bg)">06</span>
    <span class="phase-title">Wrap-Up & Evolution</span>
    <span class="phase-time">3‚Äì5 min</span>
    <svg class="phase-chevron" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.23 7.21a.75.75 0 011.06.02L10 11.168l3.71-3.938a.75.75 0 111.08 1.04l-4.25 4.5a.75.75 0 01-1.08 0l-4.25-4.5a.75.75 0 01.02-1.06z"/></svg>
  </div>
  <div class="phase-body">

    <div class="callout say">"To summarize: the system is organized around three main concerns ‚Äî a write-heavy, in-memory location tracking pipeline using Redis with geohash-based spatial indexing; a strongly consistent trip state machine on PostgreSQL with event-driven updates via Kafka; and a decoupled pricing service with precomputed surge multipliers. The key tradeoff throughout is eventual consistency for location and surge data in exchange for low-latency reads, with strong consistency reserved for trip state where correctness matters most."</div>

    <div id="evolution" class="sub">What I'd Build Next</div>
    <table>
      <thead><tr><th>Extension</th><th>Why It Matters</th><th>Architecture Impact</th></tr></thead>
      <tbody>
        <tr><td>Shared Rides (Pool)</td><td>Higher utilization, lower fares</td><td>Matching becomes a combinatorial optimization problem. Needs a batch matching window instead of serial dispatch.</td></tr>
        <tr><td>Scheduled Rides</td><td>Airport pickups, commute planning</td><td>New "scheduled" state in trip machine. Background scheduler that triggers matching N minutes before pickup.</td></tr>
        <tr><td>Multi-Region</td><td>Latency for global users</td><td>Regional deployments with independent Location + Trip services per region. Cross-region user profile replication.</td></tr>
        <tr><td>ML-based ETA</td><td>More accurate estimates</td><td>Train on Cassandra location history. Serve from a feature store. Replace simple routing API call.</td></tr>
        <tr><td>Fraud Detection</td><td>Fake GPS, driver collusion</td><td>Stream processing on location events. Anomaly detection on speed/teleportation. Async ‚Äî doesn't block hot path.</td></tr>
      </tbody>
    </table>

    <div class="callout tip"><strong>Closing framing:</strong> This design optimizes for the two things that matter most for a ride-hailing platform ‚Äî fast matching (location + dispatch) and reliable trip state (never lose a ride). Everything else is built around supporting those two pillars.</div>

  </div>
</div>


<!-- P7 -->
<div class="phase" id="p7">
  <div class="phase-header" onclick="this.closest('.phase').classList.toggle('collapsed')">
    <span class="phase-number" style="background:var(--accent-cyan)">07</span>
    <span class="phase-title">Interview Q&amp;A</span><span class="phase-time">Practice</span>
    <svg class="phase-chevron" viewBox="0 0 20 20" fill="currentColor"><path d="M6.3 6.3a1 1 0 011.4 0L10 8.6l2.3-2.3a1 1 0 111.4 1.4l-3 3a1 1 0 01-1.4 0l-3-3a1 1 0 010-1.4z"/></svg>
  </div>
  <div class="phase-body">
    <div class="callout say">"Here are the hardest questions an interviewer would ask about this design, and how to answer them. Each answer demonstrates deep understanding of the tradeoffs, not just surface knowledge."</div>

    <div style="margin:8px 0;">
      <div style="display:flex;gap:10px;align-items:flex-start;margin-bottom:8px">
        <span style="font-family:var(--font-mono);font-size:10px;padding:3px 8px;border-radius:4px;background:rgba(248,81,73,.1);color:var(--accent-red);font-weight:600;flex-shrink:0">Q1</span>
        <p style="color:var(--text);font-size:13.5px;font-weight:600;line-height:1.5;margin:0">How would you handle a sudden 5x spike in ride requests during a concert ending?</p>
      </div>
      <div style="display:flex;gap:10px;align-items:flex-start;margin-left:0px">
        <span style="font-family:var(--font-mono);font-size:10px;padding:3px 8px;border-radius:4px;background:rgba(63,185,80,.1);color:var(--accent-green);font-weight:600;flex-shrink:0">A</span>
        <p style="color:var(--text-muted);font-size:13px;line-height:1.65;margin:0">This is exactly what surge pricing is designed for ‚Äî it's not just revenue, it's a load-shedding mechanism. The pricing service detects demand/supply imbalance per geohash cell and raises the multiplier, which does two things: (1) reduces demand by discouraging price-sensitive riders, and (2) increases supply by incentivizing drivers to move toward the surge zone. On the infrastructure side, the matching service is already sharded by city, so a local spike doesn't affect other cities. The WebSocket service scales horizontally ‚Äî each instance handles a partition of connected drivers. The real bottleneck would be the matching algorithm itself: with 5x requests but not 5x drivers, we'd want to increase the search radius gradually and batch match requests to avoid the thundering herd problem.</p>
      </div>
    </div>
    <div style="margin:18px 0;">
      <div style="display:flex;gap:10px;align-items:flex-start;margin-bottom:8px">
        <span style="font-family:var(--font-mono);font-size:10px;padding:3px 8px;border-radius:4px;background:rgba(248,81,73,.1);color:var(--accent-red);font-weight:600;flex-shrink:0">Q2</span>
        <p style="color:var(--text);font-size:13.5px;font-weight:600;line-height:1.5;margin:0">Why Cassandra for location history instead of just using PostgreSQL?</p>
      </div>
      <div style="display:flex;gap:10px;align-items:flex-start;margin-left:0px">
        <span style="font-family:var(--font-mono);font-size:10px;padding:3px 8px;border-radius:4px;background:rgba(63,185,80,.1);color:var(--accent-green);font-weight:600;flex-shrink:0">A</span>
        <p style="color:var(--text-muted);font-size:13px;line-height:1.65;margin:0">Location history is a pure append workload ‚Äî we never update a past location, only write new ones. At 500K active drivers updating every 4 seconds, that's ~125K writes/sec sustained. PostgreSQL could handle this with partitioning, but Cassandra gives us: (1) linear write scalability ‚Äî just add nodes, (2) no single point of failure ‚Äî any node can accept writes, (3) natural time-series partitioning with driver_id + date as partition key, and (4) automatic TTL-based expiration for old data. The tradeoff is we can't do complex joins ‚Äî but we never need to. Location history queries are always &quot;give me driver X's positions between time A and B,&quot; which is a single partition scan in Cassandra. PostgreSQL is the right choice for trips because trips have relational integrity requirements (rider, driver, payment, route all linked), but location is just a high-velocity stream.</p>
      </div>
    </div>
    <div style="margin:18px 0;">
      <div style="display:flex;gap:10px;align-items:flex-start;margin-bottom:8px">
        <span style="font-family:var(--font-mono);font-size:10px;padding:3px 8px;border-radius:4px;background:rgba(248,81,73,.1);color:var(--accent-red);font-weight:600;flex-shrink:0">Q3</span>
        <p style="color:var(--text);font-size:13.5px;font-weight:600;line-height:1.5;margin:0">What happens if the Matching Service goes down mid-request?</p>
      </div>
      <div style="display:flex;gap:10px;align-items:flex-start;margin-left:0px">
        <span style="font-family:var(--font-mono);font-size:10px;padding:3px 8px;border-radius:4px;background:rgba(63,185,80,.1);color:var(--accent-green);font-weight:600;flex-shrink:0">A</span>
        <p style="color:var(--text-muted);font-size:13px;line-height:1.65;margin:0">The Trip Service is the source of truth, not the Matching Service. When a rider requests a ride, the Trip Service creates a trip record in state REQUESTED with a TTL. The Matching Service is called asynchronously ‚Äî if it fails, the trip stays in REQUESTED state. We have two safety nets: (1) a retry loop in the Trip Service that re-calls Matching every 5 seconds while the trip is in REQUESTED state, and (2) a timeout ‚Äî if no match after 60 seconds, the trip transitions to NO_DRIVERS and the rider is notified. Because matching is idempotent (it reads driver locations and returns the best match), retries are safe. If the entire Matching Service fleet is down, riders see &quot;no drivers available&quot; ‚Äî degraded but not broken. The worst failure mode would be matching succeeding but the response being lost ‚Äî which is why the Trip Service does the state transition, not the Matching Service.</p>
      </div>
    </div>
    <div style="margin:18px 0;">
      <div style="display:flex;gap:10px;align-items:flex-start;margin-bottom:8px">
        <span style="font-family:var(--font-mono);font-size:10px;padding:3px 8px;border-radius:4px;background:rgba(248,81,73,.1);color:var(--accent-red);font-weight:600;flex-shrink:0">Q4</span>
        <p style="color:var(--text);font-size:13.5px;font-weight:600;line-height:1.5;margin:0">How do you ensure a driver doesn't get assigned to two rides simultaneously?</p>
      </div>
      <div style="display:flex;gap:10px;align-items:flex-start;margin-left:0px">
        <span style="font-family:var(--font-mono);font-size:10px;padding:3px 8px;border-radius:4px;background:rgba(63,185,80,.1);color:var(--accent-green);font-weight:600;flex-shrink:0">A</span>
        <p style="color:var(--text-muted);font-size:13px;line-height:1.65;margin:0">This is a distributed locking problem. When the Matching Service selects a driver, it must atomically mark that driver as &quot;unavailable&quot; before returning. We use Redis with a SET NX (set-if-not-exists) lock: `SET driver:{id}:trip trip_123 NX EX 30`. If the SET succeeds, the driver is ours. If it fails, someone else claimed them ‚Äî pick the next candidate. The 30-second TTL is a safety net if the Trip Service crashes after locking but before completing the match. The Matching Service returns a ranked list of candidates and tries them in order until one lock succeeds. This means we never double-assign, but we might occasionally skip an optimal match if there's contention ‚Äî which is fine, the second-best driver 200m away is nearly as good as the best driver 150m away.</p>
      </div>
    </div>
    <div style="margin:18px 0;">
      <div style="display:flex;gap:10px;align-items:flex-start;margin-bottom:8px">
        <span style="font-family:var(--font-mono);font-size:10px;padding:3px 8px;border-radius:4px;background:rgba(248,81,73,.1);color:var(--accent-red);font-weight:600;flex-shrink:0">Q5</span>
        <p style="color:var(--text);font-size:13.5px;font-weight:600;line-height:1.5;margin:0">Why not use a single database for everything?</p>
      </div>
      <div style="display:flex;gap:10px;align-items:flex-start;margin-left:0px">
        <span style="font-family:var(--font-mono);font-size:10px;padding:3px 8px;border-radius:4px;background:rgba(63,185,80,.1);color:var(--accent-green);font-weight:600;flex-shrink:0">A</span>
        <p style="color:var(--text-muted);font-size:13px;line-height:1.65;margin:0">Because the access patterns are fundamentally different and a single database would force you to compromise on all of them. Trips need ACID transactions (state machine transitions must be atomic). Locations need 125K writes/sec with geographic queries. Surge zones need sub-millisecond reads. User sessions need TTL-based expiration. A single PostgreSQL instance could technically store all of this, but: (1) the location write volume would compete with trip transaction throughput, (2) geographic queries on Postgres require PostGIS extensions that don't scale horizontally as cleanly as Redis GEORADIUS, and (3) you'd need to over-provision for the union of all workload peaks. Polyglot persistence lets each store be optimized for its access pattern and scaled independently. The cost is operational complexity ‚Äî more systems to monitor and maintain ‚Äî which is why we only split when the access pattern genuinely demands it.</p>
      </div>
    </div>
  </div>
</div>


</main>

<script>
const observer = new IntersectionObserver(entries => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      document.querySelectorAll('nav a').forEach(a => a.classList.remove('active'));
      const link = document.querySelector(`nav a[href="#${entry.target.id}"]`);
      if (link) link.classList.add('active');
    }
  });
}, { rootMargin: '-20% 0px -70% 0px' });
document.querySelectorAll('[id]').forEach(s => { if (document.querySelector(`nav a[href="#${s.id}"]`)) observer.observe(s); });
</script>

</body>
</html>
